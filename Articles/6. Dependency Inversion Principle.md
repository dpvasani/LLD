# üîÑ Dependency Inversion Principle (DIP): Complete Guide with Notification Manager

## üéØ What is Dependency Inversion Principle?

**DIP Definition**: High-level modules should not depend on low-level modules. Both should depend on abstractions.[1][2][7]

> **"Abstractions should not depend on details. Details should depend on abstractions."** - Robert C. Martin

***

## üìä D in SOLID = Dependency Inversion Principle

```mermaid
graph TB
    subgraph "üîÑ Dependency Inversion Principle"
        A[High-Level Modules] 
        B[Low-Level Modules]
        C[Abstractions/Interfaces]
        
        A -.->|"‚ùå Should NOT depend on"| B
        A -->|"‚úÖ Should depend on"| C
        B -->|"‚úÖ Should depend on"| C
    end
    
    classDef high fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef low fill:#fff3e0,stroke:#f57c00,stroke-width:2px  
    classDef abstract fill:#e8f5e8,stroke:#388e3c,stroke-width:2px
    
    class A high
    class B low
    class C abstract
```

***

## üö® Problem Analysis: Tight Coupling

### üî¥ What Happens Without DIP?

```mermaid
graph LR
    A[NotificationManager] -->|"Direct Dependency üí•"| B[SMSSender]
    A -->|"Direct Dependency üí•"| C[EmailSender]
    A -->|"Direct Dependency üí•"| D[WhatsAppSender]
    
    E["‚ùå Problems:"] --> F["Hard to Test"]
    E --> G["Difficult to Extend"]
    E --> H["Tightly Coupled"]
    E --> I["Violates Open/Closed"]
    
    classDef problem fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef manager fill:#e1f5fe,stroke:#0277bd,stroke-width:2px
    
    class A manager
    class B,C,D,E,F,G,H,I problem
```

***

## ‚ùå BAD EXAMPLE: Notification Manager WITHOUT DIP

### üö® Tightly Coupled Implementation

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

// üì± SMS Sender - Low-level module
class SMSSender {
public:
    void sendSMS(const string& phoneNumber, const string& message) {
        cout << "üì± SMS sent to " << phoneNumber << ": " << message << endl;
        // Simulate SMS API call
        cout << "   ‚îî‚îÄ Using SMS Gateway API..." << endl;
    }
};

// üìß Email Sender - Low-level module
class EmailSender {
public:
    void sendEmail(const string& email, const string& subject, const string& body) {
        cout << "üìß Email sent to " << email << endl;
        cout << "   ‚îú‚îÄ Subject: " << subject << endl;
        cout << "   ‚îú‚îÄ Body: " << body << endl;
        cout << "   ‚îî‚îÄ Using SMTP server..." << endl;
    }
};

// üí¨ WhatsApp Sender - Low-level module
class WhatsAppSender {
public:
    void sendWhatsApp(const string& phoneNumber, const string& message) {
        cout << "üí¨ WhatsApp sent to " << phoneNumber << ": " << message << endl;
        cout << "   ‚îî‚îÄ Using WhatsApp Business API..." << endl;
    }
};

// üì∫ Slack Sender - Low-level module
class SlackSender {
public:
    void sendSlackMessage(const string& channel, const string& message) {
        cout << "üì∫ Slack message sent to #" << channel << ": " << message << endl;
        cout << "   ‚îî‚îÄ Using Slack Webhook..." << endl;
    }
};

// üö® HIGH-LEVEL MODULE WITH TIGHT COUPLING
class NotificationManager {
private:
    SMSSender smsService;           // üí• Direct dependency!
    EmailSender emailService;       // üí• Direct dependency!
    WhatsAppSender whatsappService; // üí• Direct dependency!
    SlackSender slackService;       // üí• Direct dependency!
    
public:
    // üö® PROBLEMS: Hard-coded dependencies, violates OCP
    void sendNotification(const string& type, const string& recipient, 
                         const string& message, const string& subject = "") {
        
        if (type == "SMS") {
            smsService.sendSMS(recipient, message);
        }
        else if (type == "EMAIL") {
            emailService.sendEmail(recipient, subject, message);
        }
        else if (type == "WHATSAPP") {
            whatsappService.sendWhatsApp(recipient, message);
        }
        else if (type == "SLACK") {
            slackService.sendSlackMessage(recipient, message);
        }
        // üö® Adding TELEGRAM means modifying this method!
        else {
            cout << "‚ùå Unsupported notification type: " << type << endl;
        }
    }
    
    // üí• What if we want to send to multiple channels?
    void sendUrgentNotification(const string& recipient, const string& message) {
        // Hard-coded logic - difficult to change!
        smsService.sendSMS(recipient, "URGENT: " + message);
        emailService.sendEmail(recipient, "URGENT ALERT", message);
        whatsappService.sendWhatsApp(recipient, "‚ö†Ô∏è URGENT: " + message);
    }
};

// üß™ Testing becomes difficult!
class NotificationManagerTest {
public:
    void testSendNotification() {
        NotificationManager manager;
        
        cout << "\nüß™ TESTING NOTIFICATION MANAGER (Difficult to test!)" << endl;
        cout << "====================================================" << endl;
        
        // üí• Problem: Can't mock dependencies!
        // Real SMS, Email, WhatsApp will be sent during testing!
        manager.sendNotification("SMS", "+1234567890", "Test message");
        manager.sendNotification("EMAIL", "test@example.com", "Test body", "Test Subject");
        
        cout << "\n‚ùå Problems with testing:" << endl;
        cout << "  - Can't mock external services" << endl;
        cout << "  - Real notifications sent during tests" << endl;
        cout << "  - Expensive API calls in tests" << endl;
        cout << "  - Tests depend on external services being available" << endl;
    }
};

int main() {
    cout << "üö® NOTIFICATION SYSTEM - DIP VIOLATION DEMO" << endl;
    cout << "===========================================" << endl;
    
    NotificationManager manager;
    
    cout << "\nüì± Sending various notifications:" << endl;
    manager.sendNotification("SMS", "+91-9876543210", "Your order is confirmed!");
    manager.sendNotification("EMAIL", "user@example.com", "Order confirmation details", "Order Confirmed");
    manager.sendNotification("WHATSAPP", "+91-9876543210", "Your delivery is on the way!");
    
    cout << "\nüö® Trying to send urgent notification:" << endl;
    manager.sendUrgentNotification("+91-9876543210", "System maintenance in 5 minutes");
    
    // Testing difficulties
    NotificationManagerTest test;
    test.testSendNotification();
    
    cout << "\nüí• PROBLEMS WITH THIS DESIGN:" << endl;
    cout << "=============================" << endl;
    cout << "‚ùå NotificationManager tightly coupled to concrete classes" << endl;
    cout << "‚ùå Hard to add new notification types (violates OCP)" << endl;
    cout << "‚ùå Difficult to test (can't mock dependencies)" << endl;
    cout << "‚ùå All dependencies created whether needed or not" << endl;
    cout << "‚ùå If SMS service changes, NotificationManager must change" << endl;
    cout << "‚ùå No way to configure which services to use" << endl;
    
    return 0;
}
```

### üí• Problems with Above Code:

```mermaid
graph TD
    A["üö® NotificationManager Problems"] --> B["üí• Tight Coupling"]
    A --> C["üß™ Hard to Test"]
    A --> D["üîí Violates OCP"]
    A --> E["‚ö° Performance Issues"]
    
    B --> F["Direct dependencies on concrete classes"]
    B --> G["Changes ripple through system"]
    
    C --> H["Cannot mock dependencies"]
    C --> I["Real services called in tests"]
    
    D --> J["Must modify code to add new notifications"]
    D --> K["If-else chains grow larger"]
    
    E --> L["All services instantiated even if not used"]
    E --> M["No lazy loading possible"]
```

***

## ‚úÖ SOLUTION: Notification Manager WITH DIP

### üéØ Dependency Inversion Architecture

```mermaid
graph TB
    subgraph "üèóÔ∏è DIP Architecture"
        A[NotificationManager<br/>High-Level Module]
        B[INotificationSender<br/>Abstraction Layer]
        
        subgraph "üì± Concrete Implementations"
            C[SMSNotificationSender]
            D[EmailNotificationSender] 
            E[WhatsAppNotificationSender]
            F[SlackNotificationSender]
            G[TelegramNotificationSender]
        end
    end
    
    A -->|"‚úÖ Depends on Abstraction"| B
    C -.->|"‚úÖ Implements"| B
    D -.->|"‚úÖ Implements"| B
    E -.->|"‚úÖ Implements"| B
    F -.->|"‚úÖ Implements"| B
    G -.->|"‚úÖ Implements"| B
    
    classDef high fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    classDef abstract fill:#e8f5e8,stroke:#388e3c,stroke-width:3px
    classDef concrete fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    
    class A high
    class B abstract  
    class C,D,E,F,G concrete
```

### ‚úÖ Complete DIP-Compliant Implementation

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <map>
#include <algorithm>
using namespace std;

// üéØ ABSTRACTION LAYER - Interface for all notification senders
class INotificationSender {
public:
    virtual void send(const string& recipient, const string& message, 
                     const map<string, string>& metadata = {}) = 0;
    virtual string getServiceName() const = 0;
    virtual bool isServiceAvailable() const = 0;
    virtual ~INotificationSender() = default;
};

// üìä Notification Result for better error handling
struct NotificationResult {
    bool success;
    string serviceName;
    string message;
    string errorCode;
    
    NotificationResult(bool s, const string& service, const string& msg, const string& error = "")
        : success(s), serviceName(service), message(msg), errorCode(error) {}
};

// üì± SMS Notification Sender - Implements abstraction
class SMSNotificationSender : public INotificationSender {
private:
    string apiKey;
    string gateway;
    
public:
    SMSNotificationSender(const string& key, const string& gw) 
        : apiKey(key), gateway(gw) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "üì± SMS Notification Service" << endl;
        cout << "‚îú‚îÄ Gateway: " << gateway << endl;
        cout << "‚îú‚îÄ To: " << recipient << endl;
        cout << "‚îú‚îÄ Message: " << message << endl;
        
        // Add metadata if available
        if (!metadata.empty()) {
            cout << "‚îú‚îÄ Metadata:" << endl;
            for (const auto& [key, value] : metadata) {
                cout << "‚îÇ  ‚îî‚îÄ " << key << ": " << value << endl;
            }
        }
        cout << "‚îî‚îÄ ‚úÖ SMS sent successfully via " << gateway << endl;
    }
    
    string getServiceName() const override { return "SMS"; }
    
    bool isServiceAvailable() const override {
        // Simulate service health check
        cout << "üîç Checking SMS service availability..." << endl;
        return !apiKey.empty();
    }
};

// üìß Email Notification Sender - Implements abstraction
class EmailNotificationSender : public INotificationSender {
private:
    string smtpServer;
    string username;
    
public:
    EmailNotificationSender(const string& server, const string& user)
        : smtpServer(server), username(user) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "üìß Email Notification Service" << endl;
        cout << "‚îú‚îÄ SMTP Server: " << smtpServer << endl;
        cout << "‚îú‚îÄ From: " << username << endl;
        cout << "‚îú‚îÄ To: " << recipient << endl;
        
        string subject = "Notification";
        if (metadata.find("subject") != metadata.end()) {
            subject = metadata.at("subject");
        }
        
        cout << "‚îú‚îÄ Subject: " << subject << endl;
        cout << "‚îú‚îÄ Body: " << message << endl;
        cout << "‚îî‚îÄ ‚úÖ Email sent successfully via SMTP" << endl;
    }
    
    string getServiceName() const override { return "Email"; }
    
    bool isServiceAvailable() const override {
        cout << "üîç Checking email service availability..." << endl;
        return !smtpServer.empty();
    }
};

// üí¨ WhatsApp Notification Sender - Implements abstraction
class WhatsAppNotificationSender : public INotificationSender {
private:
    string businessApiKey;
    
public:
    WhatsAppNotificationSender(const string& apiKey) : businessApiKey(apiKey) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "üí¨ WhatsApp Business Notification Service" << endl;
        cout << "‚îú‚îÄ API: WhatsApp Business API" << endl;
        cout << "‚îú‚îÄ To: " << recipient << endl;
        cout << "‚îú‚îÄ Message: " << message << endl;
        
        // WhatsApp supports media
        if (metadata.find("mediaType") != metadata.end()) {
            cout << "‚îú‚îÄ Media Type: " << metadata.at("mediaType") << endl;
        }
        
        cout << "‚îî‚îÄ ‚úÖ WhatsApp message sent successfully" << endl;
    }
    
    string getServiceName() const override { return "WhatsApp"; }
    
    bool isServiceAvailable() const override {
        cout << "üîç Checking WhatsApp Business API availability..." << endl;
        return !businessApiKey.empty();
    }
};

// üì∫ Slack Notification Sender - Implements abstraction
class SlackNotificationSender : public INotificationSender {
private:
    string webhookUrl;
    string botToken;
    
public:
    SlackNotificationSender(const string& webhook, const string& token)
        : webhookUrl(webhook), botToken(token) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "üì∫ Slack Notification Service" << endl;
        cout << "‚îú‚îÄ Channel: #" << recipient << endl;
        cout << "‚îú‚îÄ Message: " << message << endl;
        
        if (metadata.find("color") != metadata.end()) {
            cout << "‚îú‚îÄ Color: " << metadata.at("color") << endl;
        }
        
        cout << "‚îî‚îÄ ‚úÖ Slack message posted successfully" << endl;
    }
    
    string getServiceName() const override { return "Slack"; }
    
    bool isServiceAvailable() const override {
        cout << "üîç Checking Slack webhook availability..." << endl;
        return !webhookUrl.empty();
    }
};

// üÜï Telegram Notification Sender - Easy to add new service!
class TelegramNotificationSender : public INotificationSender {
private:
    string botToken;
    
public:
    TelegramNotificationSender(const string& token) : botToken(token) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "ü§ñ Telegram Bot Notification Service" << endl;
        cout << "‚îú‚îÄ Bot Token: " << botToken.substr(0, 10) << "..." << endl;
        cout << "‚îú‚îÄ Chat ID: " << recipient << endl;
        cout << "‚îú‚îÄ Message: " << message << endl;
        cout << "‚îî‚îÄ ‚úÖ Telegram message sent successfully" << endl;
    }
    
    string getServiceName() const override { return "Telegram"; }
    
    bool isServiceAvailable() const override {
        cout << "üîç Checking Telegram Bot API availability..." << endl;
        return !botToken.empty();
    }
};

// ‚úÖ HIGH-LEVEL MODULE - Now depends only on abstraction!
class NotificationManager {
private:
    vector<shared_ptr<INotificationSender>> notificationSenders;
    map<string, shared_ptr<INotificationSender>> serviceMap;
    
public:
    // ‚úÖ Dependency Injection - depends on abstraction!
    void addNotificationSender(shared_ptr<INotificationSender> sender) {
        notificationSenders.push_back(sender);
        serviceMap[sender->getServiceName()] = sender;
        cout << "üìå Registered notification service: " << sender->getServiceName() << endl;
    }
    
    // ‚úÖ Send via specific service
    NotificationResult sendNotification(const string& serviceName, const string& recipient, 
                                       const string& message, 
                                       const map<string, string>& metadata = {}) {
        
        auto it = serviceMap.find(serviceName);
        if (it == serviceMap.end()) {
            return NotificationResult(false, serviceName, "Service not found", "SERVICE_NOT_FOUND");
        }
        
        auto sender = it->second;
        
        if (!sender->isServiceAvailable()) {
            return NotificationResult(false, serviceName, "Service unavailable", "SERVICE_UNAVAILABLE");
        }
        
        try {
            sender->send(recipient, message, metadata);
            return NotificationResult(true, serviceName, "Message sent successfully");
        } catch (const exception& e) {
            return NotificationResult(false, serviceName, e.what(), "SEND_FAILED");
        }
    }
    
    // ‚úÖ Broadcast to all available services
    vector<NotificationResult> broadcastNotification(const string& recipient, const string& message,
                                                    const map<string, string>& metadata = {}) {
        vector<NotificationResult> results;
        
        cout << "\nüì¢ BROADCASTING NOTIFICATION TO ALL SERVICES" << endl;
        cout << "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê" << endl;
        
        for (auto& sender : notificationSenders) {
            if (sender->isServiceAvailable()) {
                try {
                    sender->send(recipient, message, metadata);
                    results.emplace_back(true, sender->getServiceName(), "Broadcast successful");
                } catch (const exception& e) {
                    results.emplace_back(false, sender->getServiceName(), e.what(), "BROADCAST_FAILED");
                }
                cout << "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" << endl;
            } else {
                results.emplace_back(false, sender->getServiceName(), "Service unavailable", "SERVICE_DOWN");
            }
        }
        
        return results;
    }
    
    // ‚úÖ Get available services
    vector<string> getAvailableServices() const {
        vector<string> available;
        
        for (const auto& sender : notificationSenders) {
            if (sender->isServiceAvailable()) {
                available.push_back(sender->getServiceName());
            }
        }
        
        return available;
    }
    
    // ‚úÖ Health check for all services
    void performHealthCheck() {
        cout << "\nüè• NOTIFICATION SERVICES HEALTH CHECK" << endl;
        cout << "====================================" << endl;
        
        for (const auto& sender : notificationSenders) {
            cout << "üîç Checking " << sender->getServiceName() << ": ";
            if (sender->isServiceAvailable()) {
                cout << "‚úÖ HEALTHY" << endl;
            } else {
                cout << "‚ùå UNHEALTHY" << endl;
            }
        }
    }
};

// üß™ EASY TESTING with Dependency Injection!
class MockNotificationSender : public INotificationSender {
private:
    string serviceName;
    bool shouldFail;
    
public:
    MockNotificationSender(const string& name, bool fail = false) 
        : serviceName(name), shouldFail(fail) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        if (shouldFail) {
            throw runtime_error("Mock service intentionally failed");
        }
        cout << "üß™ MOCK " << serviceName << " - Message sent to " << recipient 
             << ": " << message << endl;
    }
    
    string getServiceName() const override { return "Mock" + serviceName; }
    bool isServiceAvailable() const override { return !shouldFail; }
};

// üìä Statistics and Analytics
class NotificationAnalytics {
private:
    map<string, int> serviceCounts;
    map<string, int> successCounts;
    map<string, int> failureCounts;
    
public:
    void recordResult(const NotificationResult& result) {
        serviceCounts[result.serviceName]++;
        if (result.success) {
            successCounts[result.serviceName]++;
        } else {
            failureCounts[result.serviceName]++;
        }
    }
    
    void displayAnalytics() {
        cout << "\nüìä NOTIFICATION ANALYTICS" << endl;
        cout << "=========================" << endl;
        
        for (const auto& [service, count] : serviceCounts) {
            int success = successCounts[service];
            int failure = failureCounts[service];
            double successRate = (success * 100.0) / count;
            
            cout << "üìà " << service << ":" << endl;
            cout << "   ‚îú‚îÄ Total: " << count << endl;
            cout << "   ‚îú‚îÄ Success: " << success << " ‚úÖ" << endl;
            cout << "   ‚îú‚îÄ Failures: " << failure << " ‚ùå" << endl;
            cout << "   ‚îî‚îÄ Success Rate: " << successRate << "%" << endl;
        }
    }
};

int main() {
    cout << "‚úÖ NOTIFICATION SYSTEM - DIP COMPLIANT IMPLEMENTATION" << endl;
    cout << "====================================================" << endl;
    
    NotificationManager manager;
    NotificationAnalytics analytics;
    
    // ‚úÖ Dependency Injection - Add services dynamically
    cout << "\nüîß CONFIGURING NOTIFICATION SERVICES" << endl;
    cout << "====================================" << endl;
    
    auto smsService = make_shared<SMSNotificationSender>("SMS_API_KEY_123", "Twilio");
    auto emailService = make_shared<EmailNotificationSender>("smtp.company.com", "notifications@company.com");
    auto whatsappService = make_shared<WhatsAppNotificationSender>("WA_BUSINESS_API_456");
    auto slackService = make_shared<SlackNotificationSender>("https://hooks.slack.com/webhook", "BOT_TOKEN_789");
    auto telegramService = make_shared<TelegramNotificationSender>("TELEGRAM_BOT_TOKEN_101");
    
    manager.addNotificationSender(smsService);
    manager.addNotificationSender(emailService);
    manager.addNotificationSender(whatsappService);
    manager.addNotificationSender(slackService);
    manager.addNotificationSender(telegramService);
    
    // Health check
    manager.performHealthCheck();
    
    // ‚úÖ Send individual notifications
    cout << "\nüì± SENDING INDIVIDUAL NOTIFICATIONS" << endl;
    cout << "===================================" << endl;
    
    auto result1 = manager.sendNotification("SMS", "+91-9876543210", "Your order #12345 is confirmed!");
    analytics.recordResult(result1);
    
    cout << "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" << endl;
    
    map<string, string> emailMeta = {{"subject", "Order Confirmation"}};
    auto result2 = manager.sendNotification("Email", "customer@example.com", 
                                           "Thank you for your order. It will be delivered soon!", 
                                           emailMeta);
    analytics.recordResult(result2);
    
    cout << "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ" << endl;
    
    map<string, string> whatsappMeta = {{"mediaType", "text"}};
    auto result3 = manager.sendNotification("WhatsApp", "+91-9876543210", 
                                           "üçï Your pizza is being prepared!", whatsappMeta);
    analytics.recordResult(result3);
    
    // ‚úÖ Broadcast notification
    cout << "\nüì¢ BROADCASTING URGENT NOTIFICATION" << endl;
    cout << "===================================" << endl;
    
    map<string, string> urgentMeta = {
        {"priority", "high"},
        {"subject", "URGENT: System Maintenance"},
        {"color", "red"}
    };
    
    auto broadcastResults = manager.broadcastNotification(
        "+91-9876543210", 
        "üö® URGENT: System will be down for maintenance in 10 minutes. Please save your work!",
        urgentMeta
    );
    
    for (const auto& result : broadcastResults) {
        analytics.recordResult(result);
    }
    
    // ‚úÖ Testing with Mock services
    cout << "\nüß™ TESTING WITH MOCK SERVICES" << endl;
    cout << "=============================" << endl;
    
    NotificationManager testManager;
    auto mockSMS = make_shared<MockNotificationSender>("SMS");
    auto mockEmailFail = make_shared<MockNotificationSender>("Email", true); // This will fail
    
    testManager.addNotificationSender(mockSMS);
    testManager.addNotificationSender(mockEmailFail);
    
    auto mockResult1 = testManager.sendNotification("MockSMS", "test-recipient", "Test message");
    auto mockResult2 = testManager.sendNotification("MockEmail", "test@test.com", "Test email");
    
    cout << "Mock SMS Result: " << (mockResult1.success ? "‚úÖ Success" : "‚ùå Failed") << endl;
    cout << "Mock Email Result: " << (mockResult2.success ? "‚úÖ Success" : "‚ùå Failed") << endl;
    
    // Analytics
    analytics.displayAnalytics();
    
    // ‚úÖ Show available services
    cout << "\nüéØ AVAILABLE SERVICES" << endl;
    cout << "=====================" << endl;
    auto availableServices = manager.getAvailableServices();
    for (const string& service : availableServices) {
        cout << "‚úÖ " << service << " is available" << endl;
    }
    
    cout << "\nüéâ BENEFITS OF DIP IMPLEMENTATION:" << endl;
    cout << "==================================" << endl;
    cout << "‚úÖ Easy to add new notification services (Telegram added seamlessly)" << endl;
    cout << "‚úÖ Easy to test with mock implementations" << endl;
    cout << "‚úÖ Services can be configured at runtime" << endl;
    cout << "‚úÖ NotificationManager doesn't know about concrete implementations" << endl;
    cout << "‚úÖ Loose coupling between high-level and low-level modules" << endl;
    cout << "‚úÖ Follows Open/Closed Principle" << endl;
    cout << "‚úÖ Individual services can be developed independently" << endl;
    
    return 0;
}
```

***

## üìä DIP Benefits Visualization

### üîÑ Before vs After Comparison

```mermaid
graph TB
    subgraph "‚ùå Without DIP (Tightly Coupled)"
        A1[NotificationManager] -->|Direct| B1[SMSSender]
        A1 -->|Direct| C1[EmailSender]  
        A1 -->|Direct| D1[WhatsAppSender]
        E1[Problems:] --> F1[Hard to test]
        E1 --> G1[Difficult to extend]
        E1 --> H1[Tight coupling]
    end
    
    subgraph "‚úÖ With DIP (Loosely Coupled)"
        A2[NotificationManager] -->|Interface| B2[INotificationSender]
        C2[SMSSender] -.->|Implements| B2
        D2[EmailSender] -.->|Implements| B2
        E2[WhatsAppSender] -.->|Implements| B2
        F2[TelegramSender] -.->|Implements| B2
        G2[Benefits:] --> H2[Easy to test]
        G2 --> I2[Easy to extend]
        G2 --> J2[Loose coupling]
    end
    
    classDef bad fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef good fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    
    class A1,B1,C1,D1,E1,F1,G1,H1 bad
    class A2,B2,C2,D2,E2,F2,G2,H2,I2,J2 good
```

### üìà Scalability Comparison

```mermaid
graph LR
    subgraph "üî¥ Without DIP"
        A[Adding New Service] --> B[Modify NotificationManager]
        B --> C[Update all if-else chains]
        C --> D[Recompile entire system]
        D --> E[Retest everything]
    end
    
    subgraph "üü¢ With DIP"
        F[Adding New Service] --> G[Implement INotificationSender]
        G --> H[Register with Manager]
        H --> I[Ready to use!]
    end
    
    classDef without fill:#ffebee,stroke:#d32f2f,stroke-width:2px
    classDef with fill:#e8f5e8,stroke:#388e3c,stroke-width:2px
    
    class A,B,C,D,E without
    class F,G,H,I with
```

***

## üß™ Testing Benefits Analysis

### üî¥ Testing Without DIP vs üü¢ Testing With DIP

```mermaid
sequenceDiagram
    participant Test as Unit Test
    participant Manager as NotificationManager
    participant SMS as SMSSender (Real)
    participant Email as EmailSender (Real)
    
    Note over Test: ‚ùå Without DIP Testing
    Test->>Manager: sendNotification("SMS", ...)
    Manager->>SMS: Real SMS API call! üí∏
    SMS-->>Manager: SMS sent (costs money!)
    Manager-->>Test: Success (but expensive)
    
    Note over Test: Test depends on external services üò∞
```

```mermaid
sequenceDiagram
    participant Test as Unit Test
    participant Manager as NotificationManager  
    participant Mock as MockSender
    participant Analytics as Analytics
    
    Note over Test: ‚úÖ With DIP Testing
    Test->>Manager: addNotificationSender(mockSender)
    Test->>Manager: sendNotification("Mock", ...)
    Manager->>Mock: send() - No real API calls! üéâ
    Mock-->>Manager: Mock response
    Manager-->>Test: Success (fast & free)
    Test->>Analytics: Verify call count
    
    Note over Test: Isolated, fast, reliable tests! ‚ö°
```

***

## üéØ Key DIP Principles Applied

### 1. üéØ High-level modules don't depend on low-level modules

```cpp
// ‚ùå Without DIP
class NotificationManager {
    SMSSender sms;     // Direct dependency!
    EmailSender email; // Direct dependency!
};

// ‚úÖ With DIP  
class NotificationManager {
    vector<shared_ptr<INotificationSender>> senders; // Depends on abstraction!
};
```

### 2. üîÑ Both depend on abstractions

```cpp
// ‚úÖ Abstraction that both depend on
class INotificationSender {
public:
    virtual void send(const string& recipient, const string& message) = 0;
    virtual ~INotificationSender() = default;
};
```

### 3. üß© Details depend on abstractions (not the reverse)

```cpp
// ‚úÖ Concrete implementation depends on interface
class SMSSender : public INotificationSender {
public:
    void send(const string& recipient, const string& message) override {
        // Implementation details
    }
};
```

***

## üöÄ DIP Implementation Patterns

### üîß Constructor Injection

```cpp
class NotificationManager {
    vector<shared_ptr<INotificationSender>> senders;
    
public:
    NotificationManager(vector<shared_ptr<INotificationSender>> injectedSenders) 
        : senders(std::move(injectedSenders)) {}
};
```

### üîß Setter Injection

```cpp
class NotificationManager {
public:
    void addNotificationSender(shared_ptr<INotificationSender> sender) {
        senders.push_back(sender);
    }
};
```

### üîß Factory Pattern

```cpp
class NotificationSenderFactory {
public:
    static shared_ptr<INotificationSender> create(const string& type) {
        if (type == "SMS") return make_shared<SMSSender>();
        if (type == "Email") return make_shared<EmailSender>();
        return nullptr;
    }
};
```

***

## üìä Performance & Benefits Analysis

| Aspect | ‚ùå Without DIP | ‚úÖ With DIP |
|--------|---------------|-------------|
| **Adding New Service** | Modify existing code | Create new class only |
| **Testing** | Hard (real dependencies) | Easy (mock dependencies) |
| **Maintenance** | High coupling, risky changes | Low coupling, safe changes |
| **Team Development** | Conflicts in same files | Independent development |
| **Configuration** | Compile-time only | Runtime configuration possible |
| **Performance** | All services loaded | Lazy loading possible |
| **Error Handling** | Hard to isolate failures | Service-specific error handling |

***

## üéØ Real-World Applications

### üèóÔ∏è Where DIP is Used:

1. **üóÑÔ∏è Database Access Layers** - Repository pattern
2. **üåê Web Frameworks** - Controller dependency injection
3. **üì± Mobile Apps** - Service locator pattern
4. **‚òÅÔ∏è Cloud Services** - Provider abstraction layers
5. **üß™ Testing Frameworks** - Mock injection
6. **üîå Plugin Systems** - Interface-based plugins

***

## üèÜ Summary: DIP Benefits

### ‚úÖ Technical Benefits:
- **üîÑ Loose Coupling** - Components are independent
- **üß™ Testability** - Easy mocking and unit testing  
- **üîß Flexibility** - Runtime configuration possible
- **üìà Scalability** - Easy to add new implementations
- **üõ°Ô∏è Maintainability** - Changes are localized

### ‚úÖ Business Benefits:
- **‚ö° Faster Development** - Teams work independently
- **üí∞ Cost Effective** - Less regression testing needed
- **üöÄ Quick Time-to-Market** - Features can be developed in parallel
- **üîÑ Easy Integration** - Third-party services easy to swap
- **üìä Better Monitoring** - Service-specific analytics possible

***

## üéä Conclusion

**Dependency Inversion Principle transforms rigid, tightly-coupled systems into flexible, maintainable architectures:**

1. **üéØ High-level modules** (NotificationManager) don't depend on low-level modules (SMS, Email)
2. **üîÑ Both depend on abstractions** (INotificationSender interface)
3. **üß© Details depend on abstractions**, not the reverse
4. **üß™ Easy testing** with dependency injection and mocking
5. **üìà Scalable design** that grows with business needs

**Result: A notification system that's robust, testable, maintainable, and ready for the future!** ‚ú®üöÄ

---