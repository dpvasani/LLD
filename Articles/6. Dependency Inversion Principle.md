# ğŸ”„ Dependency Inversion Principle (DIP): Complete Guide with Notification Manager

## ğŸ¯ What is Dependency Inversion Principle?

**DIP Definition**: High-level modules should not depend on low-level modules. Both should depend on abstractions.[1][2][7]

> **"Abstractions should not depend on details. Details should depend on abstractions."** - Robert C. Martin

***

## ğŸ“Š D in SOLID = Dependency Inversion Principle

```mermaid
graph TB
    subgraph "ğŸ”„ Dependency Inversion Principle"
        A[High-Level Modules] 
        B[Low-Level Modules]
        C[Abstractions/Interfaces]
        
        A -.->|"âŒ Should NOT depend on"| B
        A -->|"âœ… Should depend on"| C
        B -->|"âœ… Should depend on"| C
    end
    
    classDef high fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef low fill:#fff3e0,stroke:#f57c00,stroke-width:2px  
    classDef abstract fill:#e8f5e8,stroke:#388e3c,stroke-width:2px
    
    class A high
    class B low
    class C abstract
```

***

## ğŸš¨ Problem Analysis: Tight Coupling

### ğŸ”´ What Happens Without DIP?

```mermaid
graph LR
    A[NotificationManager] -->|"Direct Dependency ğŸ’¥"| B[SMSSender]
    A -->|"Direct Dependency ğŸ’¥"| C[EmailSender]
    A -->|"Direct Dependency ğŸ’¥"| D[WhatsAppSender]
    
    E["âŒ Problems:"] --> F["Hard to Test"]
    E --> G["Difficult to Extend"]
    E --> H["Tightly Coupled"]
    E --> I["Violates Open/Closed"]
    
    classDef problem fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef manager fill:#e1f5fe,stroke:#0277bd,stroke-width:2px
    
    class A manager
    class B,C,D,E,F,G,H,I problem
```

***

## âŒ BAD EXAMPLE: Notification Manager WITHOUT DIP

### ğŸš¨ Tightly Coupled Implementation

```cpp
#include <iostream>
#include <string>
#include <vector>
using namespace std;

// ğŸ“± SMS Sender - Low-level module
class SMSSender {
public:
    void sendSMS(const string& phoneNumber, const string& message) {
        cout << "ğŸ“± SMS sent to " << phoneNumber << ": " << message << endl;
        // Simulate SMS API call
        cout << "   â””â”€ Using SMS Gateway API..." << endl;
    }
};

// ğŸ“§ Email Sender - Low-level module
class EmailSender {
public:
    void sendEmail(const string& email, const string& subject, const string& body) {
        cout << "ğŸ“§ Email sent to " << email << endl;
        cout << "   â”œâ”€ Subject: " << subject << endl;
        cout << "   â”œâ”€ Body: " << body << endl;
        cout << "   â””â”€ Using SMTP server..." << endl;
    }
};

// ğŸ’¬ WhatsApp Sender - Low-level module
class WhatsAppSender {
public:
    void sendWhatsApp(const string& phoneNumber, const string& message) {
        cout << "ğŸ’¬ WhatsApp sent to " << phoneNumber << ": " << message << endl;
        cout << "   â””â”€ Using WhatsApp Business API..." << endl;
    }
};

// ğŸ“º Slack Sender - Low-level module
class SlackSender {
public:
    void sendSlackMessage(const string& channel, const string& message) {
        cout << "ğŸ“º Slack message sent to #" << channel << ": " << message << endl;
        cout << "   â””â”€ Using Slack Webhook..." << endl;
    }
};

// ğŸš¨ HIGH-LEVEL MODULE WITH TIGHT COUPLING
class NotificationManager {
private:
    SMSSender smsService;           // ğŸ’¥ Direct dependency!
    EmailSender emailService;       // ğŸ’¥ Direct dependency!
    WhatsAppSender whatsappService; // ğŸ’¥ Direct dependency!
    SlackSender slackService;       // ğŸ’¥ Direct dependency!
    
public:
    // ğŸš¨ PROBLEMS: Hard-coded dependencies, violates OCP
    void sendNotification(const string& type, const string& recipient, 
                         const string& message, const string& subject = "") {
        
        if (type == "SMS") {
            smsService.sendSMS(recipient, message);
        }
        else if (type == "EMAIL") {
            emailService.sendEmail(recipient, subject, message);
        }
        else if (type == "WHATSAPP") {
            whatsappService.sendWhatsApp(recipient, message);
        }
        else if (type == "SLACK") {
            slackService.sendSlackMessage(recipient, message);
        }
        // ğŸš¨ Adding TELEGRAM means modifying this method!
        else {
            cout << "âŒ Unsupported notification type: " << type << endl;
        }
    }
    
    // ğŸ’¥ What if we want to send to multiple channels?
    void sendUrgentNotification(const string& recipient, const string& message) {
        // Hard-coded logic - difficult to change!
        smsService.sendSMS(recipient, "URGENT: " + message);
        emailService.sendEmail(recipient, "URGENT ALERT", message);
        whatsappService.sendWhatsApp(recipient, "âš ï¸ URGENT: " + message);
    }
};

// ğŸ§ª Testing becomes difficult!
class NotificationManagerTest {
public:
    void testSendNotification() {
        NotificationManager manager;
        
        cout << "\nğŸ§ª TESTING NOTIFICATION MANAGER (Difficult to test!)" << endl;
        cout << "====================================================" << endl;
        
        // ğŸ’¥ Problem: Can't mock dependencies!
        // Real SMS, Email, WhatsApp will be sent during testing!
        manager.sendNotification("SMS", "+1234567890", "Test message");
        manager.sendNotification("EMAIL", "test@example.com", "Test body", "Test Subject");
        
        cout << "\nâŒ Problems with testing:" << endl;
        cout << "  - Can't mock external services" << endl;
        cout << "  - Real notifications sent during tests" << endl;
        cout << "  - Expensive API calls in tests" << endl;
        cout << "  - Tests depend on external services being available" << endl;
    }
};

int main() {
    cout << "ğŸš¨ NOTIFICATION SYSTEM - DIP VIOLATION DEMO" << endl;
    cout << "===========================================" << endl;
    
    NotificationManager manager;
    
    cout << "\nğŸ“± Sending various notifications:" << endl;
    manager.sendNotification("SMS", "+91-9876543210", "Your order is confirmed!");
    manager.sendNotification("EMAIL", "user@example.com", "Order confirmation details", "Order Confirmed");
    manager.sendNotification("WHATSAPP", "+91-9876543210", "Your delivery is on the way!");
    
    cout << "\nğŸš¨ Trying to send urgent notification:" << endl;
    manager.sendUrgentNotification("+91-9876543210", "System maintenance in 5 minutes");
    
    // Testing difficulties
    NotificationManagerTest test;
    test.testSendNotification();
    
    cout << "\nğŸ’¥ PROBLEMS WITH THIS DESIGN:" << endl;
    cout << "=============================" << endl;
    cout << "âŒ NotificationManager tightly coupled to concrete classes" << endl;
    cout << "âŒ Hard to add new notification types (violates OCP)" << endl;
    cout << "âŒ Difficult to test (can't mock dependencies)" << endl;
    cout << "âŒ All dependencies created whether needed or not" << endl;
    cout << "âŒ If SMS service changes, NotificationManager must change" << endl;
    cout << "âŒ No way to configure which services to use" << endl;
    
    return 0;
}
```

### ğŸ’¥ Problems with Above Code:

```mermaid
graph TD
    A["ğŸš¨ NotificationManager Problems"] --> B["ğŸ’¥ Tight Coupling"]
    A --> C["ğŸ§ª Hard to Test"]
    A --> D["ğŸ”’ Violates OCP"]
    A --> E["âš¡ Performance Issues"]
    
    B --> F["Direct dependencies on concrete classes"]
    B --> G["Changes ripple through system"]
    
    C --> H["Cannot mock dependencies"]
    C --> I["Real services called in tests"]
    
    D --> J["Must modify code to add new notifications"]
    D --> K["If-else chains grow larger"]
    
    E --> L["All services instantiated even if not used"]
    E --> M["No lazy loading possible"]
```

***

## âœ… SOLUTION: Notification Manager WITH DIP

### ğŸ¯ Dependency Inversion Architecture

```mermaid
graph TB
    subgraph "ğŸ—ï¸ DIP Architecture"
        A[NotificationManager<br/>High-Level Module]
        B[INotificationSender<br/>Abstraction Layer]
        
        subgraph "ğŸ“± Concrete Implementations"
            C[SMSNotificationSender]
            D[EmailNotificationSender] 
            E[WhatsAppNotificationSender]
            F[SlackNotificationSender]
            G[TelegramNotificationSender]
        end
    end
    
    A -->|"âœ… Depends on Abstraction"| B
    C -.->|"âœ… Implements"| B
    D -.->|"âœ… Implements"| B
    E -.->|"âœ… Implements"| B
    F -.->|"âœ… Implements"| B
    G -.->|"âœ… Implements"| B
    
    classDef high fill:#e3f2fd,stroke:#1976d2,stroke-width:3px
    classDef abstract fill:#e8f5e8,stroke:#388e3c,stroke-width:3px
    classDef concrete fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    
    class A high
    class B abstract  
    class C,D,E,F,G concrete
```

### âœ… Complete DIP-Compliant Implementation

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <map>
#include <algorithm>
using namespace std;

// ğŸ¯ ABSTRACTION LAYER - Interface for all notification senders
class INotificationSender {
public:
    virtual void send(const string& recipient, const string& message, 
                     const map<string, string>& metadata = {}) = 0;
    virtual string getServiceName() const = 0;
    virtual bool isServiceAvailable() const = 0;
    virtual ~INotificationSender() = default;
};

// ğŸ“Š Notification Result for better error handling
struct NotificationResult {
    bool success;
    string serviceName;
    string message;
    string errorCode;
    
    NotificationResult(bool s, const string& service, const string& msg, const string& error = "")
        : success(s), serviceName(service), message(msg), errorCode(error) {}
};

// ğŸ“± SMS Notification Sender - Implements abstraction
class SMSNotificationSender : public INotificationSender {
private:
    string apiKey;
    string gateway;
    
public:
    SMSNotificationSender(const string& key, const string& gw) 
        : apiKey(key), gateway(gw) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "ğŸ“± SMS Notification Service" << endl;
        cout << "â”œâ”€ Gateway: " << gateway << endl;
        cout << "â”œâ”€ To: " << recipient << endl;
        cout << "â”œâ”€ Message: " << message << endl;
        
        // Add metadata if available
        if (!metadata.empty()) {
            cout << "â”œâ”€ Metadata:" << endl;
            for (const auto& [key, value] : metadata) {
                cout << "â”‚  â””â”€ " << key << ": " << value << endl;
            }
        }
        cout << "â””â”€ âœ… SMS sent successfully via " << gateway << endl;
    }
    
    string getServiceName() const override { return "SMS"; }
    
    bool isServiceAvailable() const override {
        // Simulate service health check
        cout << "ğŸ” Checking SMS service availability..." << endl;
        return !apiKey.empty();
    }
};

// ğŸ“§ Email Notification Sender - Implements abstraction
class EmailNotificationSender : public INotificationSender {
private:
    string smtpServer;
    string username;
    
public:
    EmailNotificationSender(const string& server, const string& user)
        : smtpServer(server), username(user) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "ğŸ“§ Email Notification Service" << endl;
        cout << "â”œâ”€ SMTP Server: " << smtpServer << endl;
        cout << "â”œâ”€ From: " << username << endl;
        cout << "â”œâ”€ To: " << recipient << endl;
        
        string subject = "Notification";
        if (metadata.find("subject") != metadata.end()) {
            subject = metadata.at("subject");
        }
        
        cout << "â”œâ”€ Subject: " << subject << endl;
        cout << "â”œâ”€ Body: " << message << endl;
        cout << "â””â”€ âœ… Email sent successfully via SMTP" << endl;
    }
    
    string getServiceName() const override { return "Email"; }
    
    bool isServiceAvailable() const override {
        cout << "ğŸ” Checking email service availability..." << endl;
        return !smtpServer.empty();
    }
};

// ğŸ’¬ WhatsApp Notification Sender - Implements abstraction
class WhatsAppNotificationSender : public INotificationSender {
private:
    string businessApiKey;
    
public:
    WhatsAppNotificationSender(const string& apiKey) : businessApiKey(apiKey) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "ğŸ’¬ WhatsApp Business Notification Service" << endl;
        cout << "â”œâ”€ API: WhatsApp Business API" << endl;
        cout << "â”œâ”€ To: " << recipient << endl;
        cout << "â”œâ”€ Message: " << message << endl;
        
        // WhatsApp supports media
        if (metadata.find("mediaType") != metadata.end()) {
            cout << "â”œâ”€ Media Type: " << metadata.at("mediaType") << endl;
        }
        
        cout << "â””â”€ âœ… WhatsApp message sent successfully" << endl;
    }
    
    string getServiceName() const override { return "WhatsApp"; }
    
    bool isServiceAvailable() const override {
        cout << "ğŸ” Checking WhatsApp Business API availability..." << endl;
        return !businessApiKey.empty();
    }
};

// ğŸ“º Slack Notification Sender - Implements abstraction
class SlackNotificationSender : public INotificationSender {
private:
    string webhookUrl;
    string botToken;
    
public:
    SlackNotificationSender(const string& webhook, const string& token)
        : webhookUrl(webhook), botToken(token) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "ğŸ“º Slack Notification Service" << endl;
        cout << "â”œâ”€ Channel: #" << recipient << endl;
        cout << "â”œâ”€ Message: " << message << endl;
        
        if (metadata.find("color") != metadata.end()) {
            cout << "â”œâ”€ Color: " << metadata.at("color") << endl;
        }
        
        cout << "â””â”€ âœ… Slack message posted successfully" << endl;
    }
    
    string getServiceName() const override { return "Slack"; }
    
    bool isServiceAvailable() const override {
        cout << "ğŸ” Checking Slack webhook availability..." << endl;
        return !webhookUrl.empty();
    }
};

// ğŸ†• Telegram Notification Sender - Easy to add new service!
class TelegramNotificationSender : public INotificationSender {
private:
    string botToken;
    
public:
    TelegramNotificationSender(const string& token) : botToken(token) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        cout << "ğŸ¤– Telegram Bot Notification Service" << endl;
        cout << "â”œâ”€ Bot Token: " << botToken.substr(0, 10) << "..." << endl;
        cout << "â”œâ”€ Chat ID: " << recipient << endl;
        cout << "â”œâ”€ Message: " << message << endl;
        cout << "â””â”€ âœ… Telegram message sent successfully" << endl;
    }
    
    string getServiceName() const override { return "Telegram"; }
    
    bool isServiceAvailable() const override {
        cout << "ğŸ” Checking Telegram Bot API availability..." << endl;
        return !botToken.empty();
    }
};

// âœ… HIGH-LEVEL MODULE - Now depends only on abstraction!
class NotificationManager {
private:
    vector<shared_ptr<INotificationSender>> notificationSenders;
    map<string, shared_ptr<INotificationSender>> serviceMap;
    
public:
    // âœ… Dependency Injection - depends on abstraction!
    void addNotificationSender(shared_ptr<INotificationSender> sender) {
        notificationSenders.push_back(sender);
        serviceMap[sender->getServiceName()] = sender;
        cout << "ğŸ“Œ Registered notification service: " << sender->getServiceName() << endl;
    }
    
    // âœ… Send via specific service
    NotificationResult sendNotification(const string& serviceName, const string& recipient, 
                                       const string& message, 
                                       const map<string, string>& metadata = {}) {
        
        auto it = serviceMap.find(serviceName);
        if (it == serviceMap.end()) {
            return NotificationResult(false, serviceName, "Service not found", "SERVICE_NOT_FOUND");
        }
        
        auto sender = it->second;
        
        if (!sender->isServiceAvailable()) {
            return NotificationResult(false, serviceName, "Service unavailable", "SERVICE_UNAVAILABLE");
        }
        
        try {
            sender->send(recipient, message, metadata);
            return NotificationResult(true, serviceName, "Message sent successfully");
        } catch (const exception& e) {
            return NotificationResult(false, serviceName, e.what(), "SEND_FAILED");
        }
    }
    
    // âœ… Broadcast to all available services
    vector<NotificationResult> broadcastNotification(const string& recipient, const string& message,
                                                    const map<string, string>& metadata = {}) {
        vector<NotificationResult> results;
        
        cout << "\nğŸ“¢ BROADCASTING NOTIFICATION TO ALL SERVICES" << endl;
        cout << "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•" << endl;
        
        for (auto& sender : notificationSenders) {
            if (sender->isServiceAvailable()) {
                try {
                    sender->send(recipient, message, metadata);
                    results.emplace_back(true, sender->getServiceName(), "Broadcast successful");
                } catch (const exception& e) {
                    results.emplace_back(false, sender->getServiceName(), e.what(), "BROADCAST_FAILED");
                }
                cout << "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" << endl;
            } else {
                results.emplace_back(false, sender->getServiceName(), "Service unavailable", "SERVICE_DOWN");
            }
        }
        
        return results;
    }
    
    // âœ… Get available services
    vector<string> getAvailableServices() const {
        vector<string> available;
        
        for (const auto& sender : notificationSenders) {
            if (sender->isServiceAvailable()) {
                available.push_back(sender->getServiceName());
            }
        }
        
        return available;
    }
    
    // âœ… Health check for all services
    void performHealthCheck() {
        cout << "\nğŸ¥ NOTIFICATION SERVICES HEALTH CHECK" << endl;
        cout << "====================================" << endl;
        
        for (const auto& sender : notificationSenders) {
            cout << "ğŸ” Checking " << sender->getServiceName() << ": ";
            if (sender->isServiceAvailable()) {
                cout << "âœ… HEALTHY" << endl;
            } else {
                cout << "âŒ UNHEALTHY" << endl;
            }
        }
    }
};

// ğŸ§ª EASY TESTING with Dependency Injection!
class MockNotificationSender : public INotificationSender {
private:
    string serviceName;
    bool shouldFail;
    
public:
    MockNotificationSender(const string& name, bool fail = false) 
        : serviceName(name), shouldFail(fail) {}
    
    void send(const string& recipient, const string& message, 
              const map<string, string>& metadata = {}) override {
        if (shouldFail) {
            throw runtime_error("Mock service intentionally failed");
        }
        cout << "ğŸ§ª MOCK " << serviceName << " - Message sent to " << recipient 
             << ": " << message << endl;
    }
    
    string getServiceName() const override { return "Mock" + serviceName; }
    bool isServiceAvailable() const override { return !shouldFail; }
};

// ğŸ“Š Statistics and Analytics
class NotificationAnalytics {
private:
    map<string, int> serviceCounts;
    map<string, int> successCounts;
    map<string, int> failureCounts;
    
public:
    void recordResult(const NotificationResult& result) {
        serviceCounts[result.serviceName]++;
        if (result.success) {
            successCounts[result.serviceName]++;
        } else {
            failureCounts[result.serviceName]++;
        }
    }
    
    void displayAnalytics() {
        cout << "\nğŸ“Š NOTIFICATION ANALYTICS" << endl;
        cout << "=========================" << endl;
        
        for (const auto& [service, count] : serviceCounts) {
            int success = successCounts[service];
            int failure = failureCounts[service];
            double successRate = (success * 100.0) / count;
            
            cout << "ğŸ“ˆ " << service << ":" << endl;
            cout << "   â”œâ”€ Total: " << count << endl;
            cout << "   â”œâ”€ Success: " << success << " âœ…" << endl;
            cout << "   â”œâ”€ Failures: " << failure << " âŒ" << endl;
            cout << "   â””â”€ Success Rate: " << successRate << "%" << endl;
        }
    }
};

int main() {
    cout << "âœ… NOTIFICATION SYSTEM - DIP COMPLIANT IMPLEMENTATION" << endl;
    cout << "====================================================" << endl;
    
    NotificationManager manager;
    NotificationAnalytics analytics;
    
    // âœ… Dependency Injection - Add services dynamically
    cout << "\nğŸ”§ CONFIGURING NOTIFICATION SERVICES" << endl;
    cout << "====================================" << endl;
    
    auto smsService = make_shared<SMSNotificationSender>("SMS_API_KEY_123", "Twilio");
    auto emailService = make_shared<EmailNotificationSender>("smtp.company.com", "notifications@company.com");
    auto whatsappService = make_shared<WhatsAppNotificationSender>("WA_BUSINESS_API_456");
    auto slackService = make_shared<SlackNotificationSender>("https://hooks.slack.com/webhook", "BOT_TOKEN_789");
    auto telegramService = make_shared<TelegramNotificationSender>("TELEGRAM_BOT_TOKEN_101");
    
    manager.addNotificationSender(smsService);
    manager.addNotificationSender(emailService);
    manager.addNotificationSender(whatsappService);
    manager.addNotificationSender(slackService);
    manager.addNotificationSender(telegramService);
    
    // Health check
    manager.performHealthCheck();
    
    // âœ… Send individual notifications
    cout << "\nğŸ“± SENDING INDIVIDUAL NOTIFICATIONS" << endl;
    cout << "===================================" << endl;
    
    auto result1 = manager.sendNotification("SMS", "+91-9876543210", "Your order #12345 is confirmed!");
    analytics.recordResult(result1);
    
    cout << "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" << endl;
    
    map<string, string> emailMeta = {{"subject", "Order Confirmation"}};
    auto result2 = manager.sendNotification("Email", "customer@example.com", 
                                           "Thank you for your order. It will be delivered soon!", 
                                           emailMeta);
    analytics.recordResult(result2);
    
    cout << "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" << endl;
    
    map<string, string> whatsappMeta = {{"mediaType", "text"}};
    auto result3 = manager.sendNotification("WhatsApp", "+91-9876543210", 
                                           "ğŸ• Your pizza is being prepared!", whatsappMeta);
    analytics.recordResult(result3);
    
    // âœ… Broadcast notification
    cout << "\nğŸ“¢ BROADCASTING URGENT NOTIFICATION" << endl;
    cout << "===================================" << endl;
    
    map<string, string> urgentMeta = {
        {"priority", "high"},
        {"subject", "URGENT: System Maintenance"},
        {"color", "red"}
    };
    
    auto broadcastResults = manager.broadcastNotification(
        "+91-9876543210", 
        "ğŸš¨ URGENT: System will be down for maintenance in 10 minutes. Please save your work!",
        urgentMeta
    );
    
    for (const auto& result : broadcastResults) {
        analytics.recordResult(result);
    }
    
    // âœ… Testing with Mock services
    cout << "\nğŸ§ª TESTING WITH MOCK SERVICES" << endl;
    cout << "=============================" << endl;
    
    NotificationManager testManager;
    auto mockSMS = make_shared<MockNotificationSender>("SMS");
    auto mockEmailFail = make_shared<MockNotificationSender>("Email", true); // This will fail
    
    testManager.addNotificationSender(mockSMS);
    testManager.addNotificationSender(mockEmailFail);
    
    auto mockResult1 = testManager.sendNotification("MockSMS", "test-recipient", "Test message");
    auto mockResult2 = testManager.sendNotification("MockEmail", "test@test.com", "Test email");
    
    cout << "Mock SMS Result: " << (mockResult1.success ? "âœ… Success" : "âŒ Failed") << endl;
    cout << "Mock Email Result: " << (mockResult2.success ? "âœ… Success" : "âŒ Failed") << endl;
    
    // Analytics
    analytics.displayAnalytics();
    
    // âœ… Show available services
    cout << "\nğŸ¯ AVAILABLE SERVICES" << endl;
    cout << "=====================" << endl;
    auto availableServices = manager.getAvailableServices();
    for (const string& service : availableServices) {
        cout << "âœ… " << service << " is available" << endl;
    }
    
    cout << "\nğŸ‰ BENEFITS OF DIP IMPLEMENTATION:" << endl;
    cout << "==================================" << endl;
    cout << "âœ… Easy to add new notification services (Telegram added seamlessly)" << endl;
    cout << "âœ… Easy to test with mock implementations" << endl;
    cout << "âœ… Services can be configured at runtime" << endl;
    cout << "âœ… NotificationManager doesn't know about concrete implementations" << endl;
    cout << "âœ… Loose coupling between high-level and low-level modules" << endl;
    cout << "âœ… Follows Open/Closed Principle" << endl;
    cout << "âœ… Individual services can be developed independently" << endl;
    
    return 0;
}
```

***

## ğŸ“Š DIP Benefits Visualization

### ğŸ”„ Before vs After Comparison

```mermaid
graph TB
    subgraph "âŒ Without DIP (Tightly Coupled)"
        A1[NotificationManager] -->|Direct| B1[SMSSender]
        A1 -->|Direct| C1[EmailSender]  
        A1 -->|Direct| D1[WhatsAppSender]
        E1[Problems:] --> F1[Hard to test]
        E1 --> G1[Difficult to extend]
        E1 --> H1[Tight coupling]
    end
    
    subgraph "âœ… With DIP (Loosely Coupled)"
        A2[NotificationManager] -->|Interface| B2[INotificationSender]
        C2[SMSSender] -.->|Implements| B2
        D2[EmailSender] -.->|Implements| B2
        E2[WhatsAppSender] -.->|Implements| B2
        F2[TelegramSender] -.->|Implements| B2
        G2[Benefits:] --> H2[Easy to test]
        G2 --> I2[Easy to extend]
        G2 --> J2[Loose coupling]
    end
    
    classDef bad fill:#ffebee,stroke:#c62828,stroke-width:2px
    classDef good fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    
    class A1,B1,C1,D1,E1,F1,G1,H1 bad
    class A2,B2,C2,D2,E2,F2,G2,H2,I2,J2 good
```

### ğŸ“ˆ Scalability Comparison

```mermaid
graph LR
    subgraph "ğŸ”´ Without DIP"
        A[Adding New Service] --> B[Modify NotificationManager]
        B --> C[Update all if-else chains]
        C --> D[Recompile entire system]
        D --> E[Retest everything]
    end
    
    subgraph "ğŸŸ¢ With DIP"
        F[Adding New Service] --> G[Implement INotificationSender]
        G --> H[Register with Manager]
        H --> I[Ready to use!]
    end
    
    classDef without fill:#ffebee,stroke:#d32f2f,stroke-width:2px
    classDef with fill:#e8f5e8,stroke:#388e3c,stroke-width:2px
    
    class A,B,C,D,E without
    class F,G,H,I with
```

***

## ğŸ§ª Testing Benefits Analysis

### ğŸ”´ Testing Without DIP vs ğŸŸ¢ Testing With DIP

```mermaid
sequenceDiagram
    participant Test as Unit Test
    participant Manager as NotificationManager
    participant SMS as SMSSender (Real)
    participant Email as EmailSender (Real)
    
    Note over Test: âŒ Without DIP Testing
    Test->>Manager: sendNotification("SMS", ...)
    Manager->>SMS: Real SMS API call! ğŸ’¸
    SMS-->>Manager: SMS sent (costs money!)
    Manager-->>Test: Success (but expensive)
    
    Note over Test: Test depends on external services ğŸ˜°
```

```mermaid
sequenceDiagram
    participant Test as Unit Test
    participant Manager as NotificationManager  
    participant Mock as MockSender
    participant Analytics as Analytics
    
    Note over Test: âœ… With DIP Testing
    Test->>Manager: addNotificationSender(mockSender)
    Test->>Manager: sendNotification("Mock", ...)
    Manager->>Mock: send() - No real API calls! ğŸ‰
    Mock-->>Manager: Mock response
    Manager-->>Test: Success (fast & free)
    Test->>Analytics: Verify call count
    
    Note over Test: Isolated, fast, reliable tests! âš¡
```

***

## ğŸ¯ Key DIP Principles Applied

### 1. ğŸ¯ High-level modules don't depend on low-level modules

```cpp
// âŒ Without DIP
class NotificationManager {
    SMSSender sms;     // Direct dependency!
    EmailSender email; // Direct dependency!
};

// âœ… With DIP  
class NotificationManager {
    vector<shared_ptr<INotificationSender>> senders; // Depends on abstraction!
};
```

### 2. ğŸ”„ Both depend on abstractions

```cpp
// âœ… Abstraction that both depend on
class INotificationSender {
public:
    virtual void send(const string& recipient, const string& message) = 0;
    virtual ~INotificationSender() = default;
};
```

### 3. ğŸ§© Details depend on abstractions (not the reverse)

```cpp
// âœ… Concrete implementation depends on interface
class SMSSender : public INotificationSender {
public:
    void send(const string& recipient, const string& message) override {
        // Implementation details
    }
};
```

***

## ğŸš€ DIP Implementation Patterns

### ğŸ”§ Constructor Injection

```cpp
class NotificationManager {
    vector<shared_ptr<INotificationSender>> senders;
    
public:
    NotificationManager(vector<shared_ptr<INotificationSender>> injectedSenders) 
        : senders(std::move(injectedSenders)) {}
};
```

### ğŸ”§ Setter Injection

```cpp
class NotificationManager {
public:
    void addNotificationSender(shared_ptr<INotificationSender> sender) {
        senders.push_back(sender);
    }
};
```

### ğŸ”§ Factory Pattern

```cpp
class NotificationSenderFactory {
public:
    static shared_ptr<INotificationSender> create(const string& type) {
        if (type == "SMS") return make_shared<SMSSender>();
        if (type == "Email") return make_shared<EmailSender>();
        return nullptr;
    }
};
```

***

## ğŸ“Š Performance & Benefits Analysis

| Aspect | âŒ Without DIP | âœ… With DIP |
|--------|---------------|-------------|
| **Adding New Service** | Modify existing code | Create new class only |
| **Testing** | Hard (real dependencies) | Easy (mock dependencies) |
| **Maintenance** | High coupling, risky changes | Low coupling, safe changes |
| **Team Development** | Conflicts in same files | Independent development |
| **Configuration** | Compile-time only | Runtime configuration possible |
| **Performance** | All services loaded | Lazy loading possible |
| **Error Handling** | Hard to isolate failures | Service-specific error handling |

***

## ğŸ¯ Real-World Applications

### ğŸ—ï¸ Where DIP is Used:

1. **ğŸ—„ï¸ Database Access Layers** - Repository pattern
2. **ğŸŒ Web Frameworks** - Controller dependency injection
3. **ğŸ“± Mobile Apps** - Service locator pattern
4. **â˜ï¸ Cloud Services** - Provider abstraction layers
5. **ğŸ§ª Testing Frameworks** - Mock injection
6. **ğŸ”Œ Plugin Systems** - Interface-based plugins

***

## ğŸ† Summary: DIP Benefits

### âœ… Technical Benefits:
- **ğŸ”„ Loose Coupling** - Components are independent
- **ğŸ§ª Testability** - Easy mocking and unit testing  
- **ğŸ”§ Flexibility** - Runtime configuration possible
- **ğŸ“ˆ Scalability** - Easy to add new implementations
- **ğŸ›¡ï¸ Maintainability** - Changes are localized

### âœ… Business Benefits:
- **âš¡ Faster Development** - Teams work independently
- **ğŸ’° Cost Effective** - Less regression testing needed
- **ğŸš€ Quick Time-to-Market** - Features can be developed in parallel
- **ğŸ”„ Easy Integration** - Third-party services easy to swap
- **ğŸ“Š Better Monitoring** - Service-specific analytics possible

***

## ğŸŠ Conclusion

**Dependency Inversion Principle transforms rigid, tightly-coupled systems into flexible, maintainable architectures:**

1. **ğŸ¯ High-level modules** (NotificationManager) don't depend on low-level modules (SMS, Email)
2. **ğŸ”„ Both depend on abstractions** (INotificationSender interface)
3. **ğŸ§© Details depend on abstractions**, not the reverse
4. **ğŸ§ª Easy testing** with dependency injection and mocking
5. **ğŸ“ˆ Scalable design** that grows with business needs

**Result: A notification system that's robust, testable, maintainable, and ready for the future!** âœ¨ğŸš€

---