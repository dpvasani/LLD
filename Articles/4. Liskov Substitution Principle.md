
# ğŸ”„ Liskov Substitution Principle (LSP) - Detailed Guide

## ğŸ¯ What is Liskov Substitution Principle?

**LSP Definition**: Objects of a superclass should be replaceable with objects of its subclasses without breaking the application.

> **"If S is a subtype of T, then objects of type T may be replaced with objects of type S without altering any of the desirable properties of that program"** - Barbara Liskov (1987)

***

## ğŸ§© L in SOLID = Liskov Substitution Principle

**Simple Definition**: A child class must be able to do everything its parent class can do, **without breaking anything**.

***

## ğŸ” Why LSP Matters?

- **ğŸ›¡ï¸ Reliability**: Ensures inheritance doesn't break existing functionality
- **ğŸ”„ Polymorphism**: Makes polymorphism work correctly
- **ğŸ§ª Testing**: Subclasses behave predictably
- **ğŸ“ˆ Maintainability**: Changes don't introduce unexpected bugs

***

## âŒ Classic Example: LSP Violation (Rectangle-Square Problem)

### The Problem Code (C++)

```cpp
#include <iostream>
using namespace std;

class Rectangle {
protected:
    int width, height;
    
public:
    Rectangle(int w, int h) : width(w), height(h) {}
    
    virtual void setWidth(int w) { width = w; }
    virtual void setHeight(int h) { height = h; }
    
    int getWidth() const { return width; }
    int getHeight() const { return height; }
    int getArea() const { return width * height; }
};

class Square : public Rectangle {
public:
    Square(int side) : Rectangle(side, side) {}
    
    // ğŸš¨ VIOLATION: Changing both width and height
    void setWidth(int w) override {
        width = height = w;  // Forces square constraint
    }
    
    void setHeight(int h) override {
        width = height = h;  // Forces square constraint
    }
};

// ğŸ§ª Test Function
void testRectangle(Rectangle& rect) {
    rect.setWidth(5);
    rect.setHeight(4);
    
    cout << "Expected area: 20" << endl;
    cout << "Actual area: " << rect.getArea() << endl;
    
    // âŒ This fails for Square! Expected: 20, Got: 16
    if (rect.getArea() == 20) {
        cout << "âœ… Test PASSED" << endl;
    } else {
        cout << "âŒ Test FAILED - LSP VIOLATED!" << endl;
    }
}

int main() {
    Rectangle rectangle(3, 4);
    Square square(3);
    
    cout << "Testing Rectangle:" << endl;
    testRectangle(rectangle);  // âœ… Works fine
    
    cout << "\nTesting Square:" << endl;
    testRectangle(square);     // âŒ Violates LSP!
    
    return 0;
}
```

### ğŸš¨ Output:
```
Testing Rectangle:
Expected area: 20
Actual area: 20
âœ… Test PASSED

Testing Square:
Expected area: 20
Actual area: 16
âŒ Test FAILED - LSP VIOLATED!
```

***

## âœ… Correct Approach: Following LSP

### Solution 1: Abstract Base Class

```cpp
#include <iostream>
using namespace std;

// ğŸ¯ Abstract base class
class Shape {
public:
    virtual double getArea() const = 0;
    virtual void display() const = 0;
    virtual ~Shape() = default;
};

// ğŸ“ Rectangle implementation
class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    void setDimensions(double w, double h) {
        width = w;
        height = h;
    }
    
    double getArea() const override {
        return width * height;
    }
    
    void display() const override {
        cout << "Rectangle: " << width << "x" << height 
             << " (Area: " << getArea() << ")" << endl;
    }
    
    double getWidth() const { return width; }
    double getHeight() const { return height; }
};

// â¬œ Square implementation
class Square : public Shape {
private:
    double side;
    
public:
    Square(double s) : side(s) {}
    
    void setSide(double s) { side = s; }
    
    double getArea() const override {
        return side * side;
    }
    
    void display() const override {
        cout << "Square: " << side << "x" << side 
             << " (Area: " << getArea() << ")" << endl;
    }
    
    double getSide() const { return side; }
};

// ğŸ§ª Test function that works with any Shape
void testShape(Shape& shape) {
    cout << "Shape area: " << shape.getArea() << endl;
    shape.display();
}

int main() {
    Rectangle rect(5, 4);
    Square sq(4);
    
    cout << "Testing shapes:" << endl;
    testShape(rect);  // âœ… Works perfectly
    testShape(sq);    // âœ… Works perfectly
    
    return 0;
}
```

***

## ğŸ® Real-World Example: Vehicle System

### âŒ LSP Violation Example

```cpp
#include <iostream>
using namespace std;

class Vehicle {
public:
    virtual void startEngine() {
        cout << "Engine started" << endl;
    }
    
    virtual void accelerate() {
        cout << "Vehicle accelerating" << endl;
    }
    
    virtual void brake() {
        cout << "Vehicle braking" << endl;
    }
};

class Car : public Vehicle {
public:
    void startEngine() override {
        cout << "Car engine started" << endl;
    }
};

class Bicycle : public Vehicle {
public:
    void startEngine() override {
        // ğŸš¨ LSP VIOLATION: Bicycles don't have engines!
        throw runtime_error("Bicycles don't have engines!");
    }
};

// This function expects all vehicles to have engines
void testVehicle(Vehicle& vehicle) {
    vehicle.startEngine();  // âŒ Breaks for Bicycle!
    vehicle.accelerate();
    vehicle.brake();
}
```

### âœ… LSP Compliant Solution

```cpp
#include <iostream>
using namespace std;

// ğŸ¯ Base Vehicle class
class Vehicle {
public:
    virtual void accelerate() {
        cout << "Vehicle accelerating" << endl;
    }
    
    virtual void brake() {
        cout << "Vehicle braking" << endl;
    }
    
    virtual void display() const = 0;
    virtual ~Vehicle() = default;
};

// ğŸš— Motorized vehicles
class MotorVehicle : public Vehicle {
public:
    virtual void startEngine() {
        cout << "Engine started" << endl;
    }
    
    virtual void stopEngine() {
        cout << "Engine stopped" << endl;
    }
};

// ğŸš™ Car implementation
class Car : public MotorVehicle {
public:
    void startEngine() override {
        cout << "Car engine started with key" << endl;
    }
    
    void display() const override {
        cout << "ğŸš— This is a Car" << endl;
    }
};

// ğŸï¸ Motorcycle implementation
class Motorcycle : public MotorVehicle {
public:
    void startEngine() override {
        cout << "Motorcycle engine started with button" << endl;
    }
    
    void display() const override {
        cout << "ğŸï¸ This is a Motorcycle" << endl;
    }
};

// ğŸš² Bicycle implementation
class Bicycle : public Vehicle {
public:
    void accelerate() override {
        cout << "Pedaling faster" << endl;
    }
    
    void display() const override {
        cout << "ğŸš² This is a Bicycle" << endl;
    }
};

// âœ… Functions that work with appropriate base classes
void testVehicle(Vehicle& vehicle) {
    vehicle.display();
    vehicle.accelerate();
    vehicle.brake();
    cout << "---" << endl;
}

void testMotorVehicle(MotorVehicle& motor) {
    motor.display();
    motor.startEngine();
    motor.accelerate();
    motor.brake();
    motor.stopEngine();
    cout << "---" << endl;
}

int main() {
    Car car;
    Motorcycle motorcycle;
    Bicycle bicycle;
    
    cout << "Testing all vehicles:" << endl;
    testVehicle(car);
    testVehicle(motorcycle);
    testVehicle(bicycle);  // âœ… Works fine now!
    
    cout << "\nTesting motor vehicles:" << endl;
    testMotorVehicle(car);
    testMotorVehicle(motorcycle);
    // testMotorVehicle(bicycle);  // Won't compile - correct!
    
    return 0;
}
```

***

## ğŸ“Š Visual Representation

```mermaid
graph TD
    A["ğŸš— Vehicle"] --> B["ğŸš™ MotorVehicle"]
    A --> C["ğŸš² Bicycle"]
    B --> D["ğŸš— Car"]
    B --> E["ğŸï¸ Motorcycle"]
    
    F["âŒ Bad Design"] --> G["Vehicle has startEngine()"]
    G --> H["Bicycle throws exception"]
    
    I["âœ… Good Design"] --> J["Proper inheritance hierarchy"]
    J --> K["Each subclass can do everything parent can"]
```

***

## ğŸ¯ LSP Rules to Follow

### âœ… Do's:
1. **Strengthen postconditions** (subclass can do more)
2. **Weaken preconditions** (subclass can accept more inputs)
3. **Preserve method signatures**
4. **Don't throw new exceptions** in subclass methods

### âŒ Don'ts:
1. **Don't strengthen preconditions** (subclass can't be more restrictive)
2. **Don't weaken postconditions** (subclass can't do less)
3. **Don't change expected behavior**
4. **Don't throw unexpected exceptions**

***

## ğŸ”§ How to Identify LSP Violations

### ğŸš¨ Warning Signs:
- Subclass throws exceptions that parent doesn't
- Subclass has empty implementations
- Subclass overrides methods to do nothing
- "Is-a" relationship doesn't work in practice
- Need type checking (`instanceof`, `dynamic_cast`)

### ğŸ§ª The Substitution Test:
```cpp
// If you can't replace Parent with Child here, LSP is violated
void function(Parent& obj) {
    // This should work with any Child object
    obj.method();
}
```

***

## ğŸ“ˆ Benefits of Following LSP

| Benefit | Description | Example |
|---------|-------------|---------|
| **ğŸ”„ Polymorphism** | Runtime substitution works correctly | `Vehicle*` can point to any vehicle type |
| **ğŸ§ª Testing** | Tests written for base class work for all subclasses | Test `Shape` works for all shapes |
| **ğŸ›¡ï¸ Reliability** | No unexpected behavior when using inheritance | Functions don't break with subclasses |
| **ğŸ“ˆ Maintainability** | Changes don't introduce subtle bugs | Adding new shapes doesn't break existing code |

***

## ğŸ® Interactive Example: Payment System

```cpp
#include <iostream>
#include <string>
using namespace std;

class PaymentProcessor {
public:
    virtual bool processPayment(double amount) {
        if (amount <= 0) return false;
        return performPayment(amount);
    }
    
protected:
    virtual bool performPayment(double amount) = 0;
    
public:
    virtual string getPaymentMethod() const = 0;
    virtual ~PaymentProcessor() = default;
};

class CreditCardProcessor : public PaymentProcessor {
protected:
    bool performPayment(double amount) override {
        cout << "Processing $" << amount << " via Credit Card" << endl;
        return true;  // Assume success
    }
    
public:
    string getPaymentMethod() const override {
        return "Credit Card";
    }
};

class PayPalProcessor : public PaymentProcessor {
protected:
    bool performPayment(double amount) override {
        cout << "Processing $" << amount << " via PayPal" << endl;
        return true;  // Assume success
    }
    
public:
    string getPaymentMethod() const override {
        return "PayPal";
    }
};

// âœ… This function works with ANY payment processor (LSP compliant)
void processOrder(PaymentProcessor& processor, double amount) {
    cout << "Processing order with " << processor.getPaymentMethod() << endl;
    
    if (processor.processPayment(amount)) {
        cout << "âœ… Payment successful!" << endl;
    } else {
        cout << "âŒ Payment failed!" << endl;
    }
    cout << "---" << endl;
}

int main() {
    CreditCardProcessor creditCard;
    PayPalProcessor paypal;
    
    // âœ… Both work seamlessly - LSP respected!
    processOrder(creditCard, 99.99);
    processOrder(paypal, 149.50);
    
    return 0;
}
```

***

## ğŸ† Summary

**LSP ensures that inheritance actually works as expected:**

- ğŸ”„ **Substitutability**: Child objects can replace parent objects
- ğŸ¯ **Behavioral compatibility**: Subclasses preserve parent's contract
- ğŸ›¡ï¸ **Reliability**: No surprises when using polymorphism
- ğŸ§ª **Testability**: Tests for parent work for all children

**Remember**: If you can't substitute a child for its parent without breaking something, you're violating LSP! ğŸš¨

---
# ğŸ”„ Classic Rectangle-Square LSP Violation & Solution

## ğŸš¨ The Classic Problem: Rectangle-Square Dilemma

The **Rectangle-Square problem** is the most famous example of Liskov Substitution Principle violation. Let's see why "A square is a rectangle" doesn't work in programming!

***

## âŒ LSP VIOLATION: The Broken Implementation

### ğŸ§® Mathematical Reality vs Programming Reality

**Mathematically**: Every square IS a rectangle (special case where width = height)  
**Programming**: Square behavior breaks Rectangle's contract!

### ğŸ’¥ The Problematic Code

```cpp
#include <iostream>
#include <cassert>
using namespace std;

class Rectangle {
protected:
    int width, height;
    
public:
    Rectangle(int w, int h) : width(w), height(h) {}
    
    // ğŸ¯ These methods define Rectangle's contract
    virtual void setWidth(int w) { 
        width = w; 
        cout << "Rectangle: Set width to " << w << endl;
    }
    
    virtual void setHeight(int h) { 
        height = h; 
        cout << "Rectangle: Set height to " << h << endl;
    }
    
    int getWidth() const { return width; }
    int getHeight() const { return height; }
    int getArea() const { return width * height; }
    
    void display() const {
        cout << "Rectangle: " << width << "x" << height 
             << " (Area: " << getArea() << ")" << endl;
    }
};

class Square : public Rectangle {
public:
    Square(int side) : Rectangle(side, side) {}
    
    // ğŸš¨ LSP VIOLATION: Changing both dimensions when only one should change
    void setWidth(int w) override {
        width = height = w;  // Forces square constraint
        cout << "Square: Set both width and height to " << w << endl;
    }
    
    void setHeight(int h) override {
        width = height = h;  // Forces square constraint  
        cout << "Square: Set both width and height to " << h << endl;
    }
};

// ğŸ§ª The Breaking Test Function
void testRectangleBehavior(Rectangle& rect) {
    cout << "\n=== Testing Rectangle Behavior ===" << endl;
    
    cout << "Initial state: ";
    rect.display();
    
    cout << "\nStep 1: Setting width to 5" << endl;
    rect.setWidth(5);
    rect.display();
    
    cout << "\nStep 2: Setting height to 4" << endl;
    rect.setHeight(4);
    rect.display();
    
    cout << "\nExpected behavior: Width=5, Height=4, Area=20" << endl;
    cout << "Actual result: Width=" << rect.getWidth() 
         << ", Height=" << rect.getHeight() 
         << ", Area=" << rect.getArea() << endl;
    
    // ğŸ¯ Rectangle Contract: Changing width shouldn't affect height
    if (rect.getWidth() == 5 && rect.getHeight() == 4 && rect.getArea() == 20) {
        cout << "âœ… TEST PASSED: Rectangle contract respected" << endl;
    } else {
        cout << "âŒ TEST FAILED: LSP VIOLATED!" << endl;
        cout << "   Width and height should be independent!" << endl;
    }
}

// ğŸ¯ Another test that demonstrates the violation
void testWidthIndependence(Rectangle& rect) {
    cout << "\n=== Testing Width Independence ===" << endl;
    
    rect.setWidth(10);
    rect.setHeight(5);
    int originalHeight = rect.getHeight();
    
    cout << "After setting width=10, height=5: ";
    rect.display();
    
    rect.setWidth(8);  // This should NOT change height
    cout << "After changing width to 8: ";
    rect.display();
    
    if (rect.getHeight() == originalHeight) {
        cout << "âœ… PASS: Height unchanged when width modified" << endl;
    } else {
        cout << "âŒ FAIL: Height changed when width modified!" << endl;
        cout << "   Expected height: " << originalHeight 
             << ", Got: " << rect.getHeight() << endl;
    }
}

int main() {
    cout << "ğŸ”¸ DEMONSTRATING LSP VIOLATION ğŸ”¸" << endl;
    
    Rectangle rectangle(3, 4);
    Square square(3);
    
    cout << "\nğŸ“ Testing with Rectangle:" << endl;
    testRectangleBehavior(rectangle);
    testWidthIndependence(rectangle);
    
    cout << "\nâ¬œ Testing with Square (LSP Violation):" << endl;
    testRectangleBehavior(square);     // âŒ This will fail!
    testWidthIndependence(square);     // âŒ This will also fail!
    
    return 0;
}
```

### ğŸ’¥ Output (Showing the Violation):

```
ğŸ”¸ DEMONSTRATING LSP VIOLATION ğŸ”¸

ğŸ“ Testing with Rectangle:

=== Testing Rectangle Behavior ===
Initial state: Rectangle: 3x4 (Area: 12)

Step 1: Setting width to 5
Rectangle: Set width to 5
Rectangle: 5x4 (Area: 20)

Step 2: Setting height to 4
Rectangle: Set height to 4
Rectangle: 5x4 (Area: 20)

Expected behavior: Width=5, Height=4, Area=20
Actual result: Width=5, Height=4, Area=20
âœ… TEST PASSED: Rectangle contract respected

=== Testing Width Independence ===
After setting width=10, height=5: Rectangle: 10x5 (Area: 50)
After changing width to 8: Rectangle: 8x5 (Area: 40)
âœ… PASS: Height unchanged when width modified

â¬œ Testing with Square (LSP Violation):

=== Testing Rectangle Behavior ===
Initial state: Rectangle: 3x3 (Area: 9)

Step 1: Setting width to 5
Square: Set both width and height to 5
Rectangle: 5x5 (Area: 25)

Step 2: Setting height to 4
Square: Set both width and height to 4
Rectangle: 4x4 (Area: 16)

Expected behavior: Width=5, Height=4, Area=20
Actual result: Width=4, Height=4, Area=16
âŒ TEST FAILED: LSP VIOLATED!
   Width and height should be independent!

=== Testing Width Independence ===
After setting width=10, height=5: Rectangle: 5x5 (Area: 25)
After changing width to 8: Rectangle: 8x8 (Area: 64)
âŒ FAIL: Height changed when width modified!
   Expected height: 5, Got: 8
```

***

## ğŸš¨ Why This Violates LSP

### 1. **Broken Contract** ğŸ“œ
- Rectangle contract: `setWidth()` only changes width
- Square breaks this: `setWidth()` changes both width AND height

### 2. **Unexpected Behavior** ğŸ˜±
- Client code expects width/height independence
- Square coupling them breaks this expectation

### 3. **Substitution Fails** ğŸ”„
- Can't substitute Square for Rectangle without breaking functionality
- Tests that pass for Rectangle fail for Square

***

## âœ… SOLUTION 1: Separate Hierarchy (Recommended)

```cpp
#include <iostream>
using namespace std;

// ğŸ¯ Abstract base class - no concrete behavior that can be violated
class Shape {
public:
    virtual double getArea() const = 0;
    virtual double getPerimeter() const = 0;
    virtual void display() const = 0;
    virtual ~Shape() = default;
    
    // Common behavior that works for all shapes
    virtual bool isValid() const {
        return getArea() > 0;
    }
};

// ğŸ“ Rectangle with independent width/height
class Rectangle : public Shape {
private:
    double width, height;
    
public:
    Rectangle(double w, double h) : width(w), height(h) {}
    
    // Rectangle-specific methods
    void setWidth(double w) { 
        width = w; 
        cout << "Rectangle: Width set to " << w << endl;
    }
    
    void setHeight(double h) { 
        height = h; 
        cout << "Rectangle: Height set to " << h << endl;
    }
    
    void setDimensions(double w, double h) {
        width = w;
        height = h;
        cout << "Rectangle: Dimensions set to " << w << "x" << h << endl;
    }
    
    // Shape interface implementation
    double getArea() const override {
        return width * height;
    }
    
    double getPerimeter() const override {
        return 2 * (width + height);
    }
    
    void display() const override {
        cout << "ğŸ“ Rectangle: " << width << "x" << height 
             << " (Area: " << getArea() << ", Perimeter: " 
             << getPerimeter() << ")" << endl;
    }
    
    // Getters
    double getWidth() const { return width; }
    double getHeight() const { return height; }
};

// â¬œ Square with single dimension
class Square : public Shape {
private:
    double side;
    
public:
    Square(double s) : side(s) {}
    
    // Square-specific methods
    void setSide(double s) { 
        side = s; 
        cout << "Square: Side set to " << s << endl;
    }
    
    // Shape interface implementation
    double getArea() const override {
        return side * side;
    }
    
    double getPerimeter() const override {
        return 4 * side;
    }
    
    void display() const override {
        cout << "â¬œ Square: " << side << "x" << side 
             << " (Area: " << getArea() << ", Perimeter: " 
             << getPerimeter() << ")" << endl;
    }
    
    // Getter
    double getSide() const { return side; }
};

// âœ… Functions that work with appropriate abstractions
void testShape(Shape& shape) {
    cout << "\n=== Testing Shape Interface ===" << endl;
    shape.display();
    cout << "Area: " << shape.getArea() << endl;
    cout << "Perimeter: " << shape.getPerimeter() << endl;
    cout << "Valid: " << (shape.isValid() ? "Yes" : "No") << endl;
}

void testRectangle(Rectangle& rect) {
    cout << "\n=== Testing Rectangle-Specific Behavior ===" << endl;
    rect.display();
    
    rect.setWidth(8);
    rect.display();
    
    rect.setHeight(6);
    rect.display();
    
    cout << "âœ… Width and height modified independently!" << endl;
}

void testSquare(Square& square) {
    cout << "\n=== Testing Square-Specific Behavior ===" << endl;
    square.display();
    
    square.setSide(7);
    square.display();
    
    cout << "âœ… Square maintains equal sides!" << endl;
}

int main() {
    cout << "ğŸ¯ LSP COMPLIANT SOLUTION" << endl;
    
    Rectangle rect(5, 4);
    Square square(4);
    
    // âœ… Both work perfectly with Shape interface
    testShape(rect);
    testShape(square);
    
    // âœ… Each works with its specific interface
    testRectangle(rect);
    testSquare(square);
    
    cout << "\nğŸ† All tests pass - LSP respected!" << endl;
    
    return 0;
}
```

***

## âœ… SOLUTION 2: Immutable Shapes

```cpp
#include <iostream>
using namespace std;

class ImmutableShape {
public:
    virtual double getArea() const = 0;
    virtual void display() const = 0;
    virtual ~ImmutableShape() = default;
};

class ImmutableRectangle : public ImmutableShape {
private:
    const double width, height;
    
public:
    ImmutableRectangle(double w, double h) : width(w), height(h) {}
    
    double getArea() const override {
        return width * height;
    }
    
    void display() const override {
        cout << "Immutable Rectangle: " << width << "x" << height 
             << " (Area: " << getArea() << ")" << endl;
    }
    
    // Factory methods for creating new instances
    ImmutableRectangle withWidth(double w) const {
        return ImmutableRectangle(w, height);
    }
    
    ImmutableRectangle withHeight(double h) const {
        return ImmutableRectangle(width, h);
    }
    
    double getWidth() const { return width; }
    double getHeight() const { return height; }
};

class ImmutableSquare : public ImmutableShape {
private:
    const double side;
    
public:
    ImmutableSquare(double s) : side(s) {}
    
    double getArea() const override {
        return side * side;
    }
    
    void display() const override {
        cout << "Immutable Square: " << side << "x" << side 
             << " (Area: " << getArea() << ")" << endl;
    }
    
    ImmutableSquare withSide(double s) const {
        return ImmutableSquare(s);
    }
    
    double getSide() const { return side; }
};
```

***

## ğŸ“Š Comparison: Violation vs Solution

```mermaid
graph TD
    subgraph "âŒ LSP Violation"
        A[Rectangle] --> B[Square]
        B --> C["setWidth() changes height too!"]
        C --> D["Contract broken ğŸ’¥"]
    end
    
    subgraph "âœ… LSP Compliant"
        E[Shape] --> F[Rectangle]
        E --> G[Square]
        F --> H["Independent width/height"]
        G --> I["Single side dimension"]
        H --> J["Contract preserved âœ…"]
        I --> J
    end
```

***

## ğŸ¯ Key Takeaways

### ğŸš¨ LSP Violation Signs:
- Child class changes parent's expected behavior
- Need to check object type before using (`instanceof`)
- Exceptions thrown in child that parent doesn't throw
- Child class has stronger preconditions

### âœ… LSP Compliance:
- Child objects can replace parent objects seamlessly
- All parent methods work as expected in child
- No type checking needed
- Behavioral compatibility maintained

### ğŸ› ï¸ Solutions:
1. **Separate hierarchies** - Don't force "is-a" when behavior differs
2. **Immutable objects** - Prevent state modification issues
3. **Composition over inheritance** - Use "has-a" relationships
4. **Interface segregation** - Create smaller, focused contracts

***

## ğŸ† The Golden Rule

> **"If it walks like a duck and quacks like a duck, but needs batteries - you probably have the wrong abstraction!"**

**LSP ensures that inheritance actually means "is-a" in behavior, not just in structure!** ğŸ¦†âœ¨

----
# ğŸ½ï¸ Swiggy User System: LSP Violation Example with KYC

## ğŸ¯ The Problem: KYC in User Base Class

In Swiggy's system, there are different types of users, but **not all users need KYC verification**. Let's see how this creates an LSP violation!

***

## âŒ LSP VIOLATION: KYC in Base User Class

```cpp
#include <iostream>
#include <string>
#include <stdexcept>
using namespace std;

// ğŸš¨ PROBLEMATIC BASE CLASS - Forces KYC on all users
class User {
protected:
    string name;
    string phoneNumber;
    string email;
    bool kycCompleted;
    
public:
    User(const string& n, const string& phone, const string& mail) 
        : name(n), phoneNumber(phone), email(mail), kycCompleted(false) {}
    
    virtual void login() {
        cout << "ğŸ” " << name << " logged in successfully!" << endl;
    }
    
    virtual void logout() {
        cout << "ğŸ‘‹ " << name << " logged out!" << endl;
    }
    
    // ğŸš¨ PROBLEM: All users forced to have KYC method
    virtual void performKYC() {
        cout << "ğŸ“‹ Performing KYC for " << name << endl;
        cout << "ğŸ“„ Document verification in progress..." << endl;
        kycCompleted = true;
        cout << "âœ… KYC completed for " << name << endl;
    }
    
    virtual void displayUserInfo() {
        cout << "ğŸ‘¤ User: " << name << endl;
        cout << "ğŸ“ Phone: " << phoneNumber << endl;
        cout << "ğŸ“§ Email: " << email << endl;
        cout << "ğŸ†” KYC Status: " << (kycCompleted ? "âœ… Completed" : "âŒ Pending") << endl;
    }
    
    bool isKYCCompleted() const { return kycCompleted; }
};

// ğŸ‘¥ Customer class - KYC not needed!
class Customer : public User {
public:
    Customer(const string& n, const string& phone, const string& mail)
        : User(n, phone, mail) {}
    
    // ğŸš¨ LSP VIOLATION: Customers don't need KYC!
    void performKYC() override {
        cout << "âš ï¸  WARNING: Customers don't need KYC verification!" << endl;
        cout << "ğŸš« This operation is not supported for customers!" << endl;
        // Throwing exception breaks LSP!
        throw runtime_error("KYC not required for customers");
    }
    
    void placeOrder() {
        cout << "ğŸ›’ " << name << " is browsing restaurants..." << endl;
        cout << "ğŸ• Order placed successfully!" << endl;
    }
};

// ğŸšš Delivery Partner class - KYC needed
class DeliveryPartner : public User {
private:
    string vehicleType;
    string licenseNumber;
    
public:
    DeliveryPartner(const string& n, const string& phone, const string& mail, 
                   const string& vehicle, const string& license)
        : User(n, phone, mail), vehicleType(vehicle), licenseNumber(license) {}
    
    void performKYC() override {
        cout << "ğŸ“‹ Performing detailed KYC for delivery partner " << name << endl;
        cout << "ğŸ†” Verifying identity documents..." << endl;
        cout << "ğŸš— Verifying vehicle: " << vehicleType << endl;
        cout << "ğŸªª  Verifying license: " << licenseNumber << endl;
        kycCompleted = true;
        cout << "âœ… KYC completed! Ready for delivery assignments!" << endl;
    }
    
    void startDelivery() {
        if (!kycCompleted) {
            cout << "âŒ Cannot start delivery - KYC not completed!" << endl;
            return;
        }
        cout << "ğŸšš " << name << " started delivery on " << vehicleType << endl;
    }
};

// ğŸª Restaurant Owner class - KYC needed
class RestaurantOwner : public User {
private:
    string restaurantName;
    string businessLicense;
    
public:
    RestaurantOwner(const string& n, const string& phone, const string& mail,
                   const string& restaurant, const string& license)
        : User(n, phone, mail), restaurantName(restaurant), businessLicense(license) {}
    
    void performKYC() override {
        cout << "ğŸ“‹ Performing business KYC for " << name << endl;
        cout << "ğŸª Restaurant: " << restaurantName << endl;
        cout << "ğŸ“œ Verifying business license: " << businessLicense << endl;
        cout << "ğŸ’¼ Verifying tax documents..." << endl;
        kycCompleted = true;
        cout << "âœ… Business KYC completed! Restaurant can accept orders!" << endl;
    }
    
    void manageMenu() {
        if (!kycCompleted) {
            cout << "âŒ Complete KYC first before managing menu!" << endl;
            return;
        }
        cout << "ğŸ“‹ " << name << " is managing menu for " << restaurantName << endl;
    }
};

// ğŸ§ª Function that demonstrates LSP violation
void processUserRegistration(User& user) {
    cout << "\nğŸ¯ PROCESSING USER REGISTRATION" << endl;
    cout << "================================" << endl;
    
    user.login();
    user.displayUserInfo();
    
    cout << "\nğŸ“‹ Starting KYC process..." << endl;
    try {
        user.performKYC();  // ğŸ’¥ This will break for Customer!
        cout << "âœ… Registration completed successfully!" << endl;
    } catch (const exception& e) {
        cout << "âŒ Registration failed: " << e.what() << endl;
    }
    
    user.logout();
}

int main() {
    cout << "ğŸ½ï¸  SWIGGY USER SYSTEM - LSP VIOLATION DEMO" << endl;
    cout << "==========================================" << endl;
    
    // Creating different types of users
    Customer customer("Alice Johnson", "+91-9876543210", "alice@email.com");
    DeliveryPartner deliveryGuy("Bob Smith", "+91-8765432109", "bob@email.com", 
                               "Motorcycle", "DL123456789");
    RestaurantOwner owner("Charlie Brown", "+91-7654321098", "charlie@email.com",
                         "Charlie's Pizza", "BL987654321");
    
    cout << "\nğŸ”¸ Testing with Customer (Should work fine):" << endl;
    processUserRegistration(customer);  // âŒ This will fail!
    
    cout << "\nğŸ”¸ Testing with Delivery Partner:" << endl;
    processUserRegistration(deliveryGuy);  // âœ… This works
    
    cout << "\nğŸ”¸ Testing with Restaurant Owner:" << endl;
    processUserRegistration(owner);  // âœ… This works
    
    return 0;
}
```


### ğŸ’¥ Output (Showing LSP Violation):

```
ğŸ½ï¸  SWIGGY USER SYSTEM - LSP VIOLATION DEMO
==========================================

ğŸ”¸ Testing with Customer (Should work fine):

ğŸ¯ PROCESSING USER REGISTRATION
================================
ğŸ” Alice Johnson logged in successfully!
ğŸ‘¤ User: Alice Johnson
ğŸ“ Phone: +91-9876543210
ğŸ“§ Email: alice@email.com
ğŸ†” KYC Status: âŒ Pending

ğŸ“‹ Starting KYC process...
âš ï¸  WARNING: Customers don't need KYC verification!
ğŸš« This operation is not supported for customers!
âŒ Registration failed: KYC not required for customers

ğŸ”¸ Testing with Delivery Partner:
...
âœ… Registration completed successfully!

ğŸ”¸ Testing with Restaurant Owner:
...
âœ… Registration completed successfully!
```


***

## ğŸš¨ Why This Violates LSP

### 1. **Contract Violation** ğŸ“œ

- Base `User` class promises `performKYC()` works
- `Customer` breaks this by throwing exceptions


### 2. **Substitution Failure** ğŸ”„

- Can't substitute `Customer` for `User` without breaking code
- Function `processUserRegistration()` fails for customers


### 3. **Unexpected Behavior** ğŸ˜±

- Client expects all users to support KYC
- Customer throws exception instead

***

## âœ… SOLUTION: Proper Inheritance Hierarchy

```cpp
#include <iostream>
#include <string>
using namespace std;

// ğŸ¯ Base User class - Only common functionality
class User {
protected:
    string name;
    string phoneNumber;
    string email;
    
public:
    User(const string& n, const string& phone, const string& mail)
        : name(n), phoneNumber(phone), email(mail) {}
    
    virtual void login() {
        cout << "ğŸ” " << name << " logged in successfully!" << endl;
    }
    
    virtual void logout() {
        cout << "ğŸ‘‹ " << name << " logged out!" << endl;
    }
    
    virtual void displayUserInfo() {
        cout << "ğŸ‘¤ User: " << name << endl;
        cout << "ğŸ“ Phone: " << phoneNumber << endl;
        cout << "ğŸ“§ Email: " << email << endl;
    }
    
    string getName() const { return name; }
    virtual ~User() = default;
};

// ğŸ’¼ Partner class - For users who need KYC (Business partners)
class Partner : public User {
protected:
    bool kycCompleted;
    
public:
    Partner(const string& n, const string& phone, const string& mail)
        : User(n, phone, mail), kycCompleted(false) {}
    
    virtual void performKYC() = 0;  // Pure virtual - must implement
    
    bool isKYCCompleted() const { return kycCompleted; }
    
    void displayUserInfo() override {
        User::displayUserInfo();
        cout << "ğŸ†” KYC Status: " << (kycCompleted ? "âœ… Completed" : "âŒ Pending") << endl;
        cout << "ğŸ‘” User Type: Business Partner" << endl;
    }
};

// ğŸ‘¥ Customer class - No KYC needed!
class Customer : public User {
public:
    Customer(const string& n, const string& phone, const string& mail)
        : User(n, phone, mail) {}
    
    void placeOrder() {
        cout << "ğŸ›’ " << name << " is browsing restaurants..." << endl;
        cout << "ğŸ• Order placed successfully!" << endl;
    }
    
    void displayUserInfo() override {
        User::displayUserInfo();
        cout << "ğŸ›ï¸  User Type: Customer" << endl;
    }
};

// ğŸšš Delivery Partner class
class DeliveryPartner : public Partner {
private:
    string vehicleType;
    string licenseNumber;
    
public:
    DeliveryPartner(const string& n, const string& phone, const string& mail,
                   const string& vehicle, const string& license)
        : Partner(n, phone, mail), vehicleType(vehicle), licenseNumber(license) {}
    
    void performKYC() override {
        cout << "ğŸ“‹ Performing delivery partner KYC for " << name << endl;
        cout << "ğŸ†” Verifying identity documents..." << endl;
        cout << "ğŸš— Verifying vehicle: " << vehicleType << endl;
        cout << "ğŸªª  Verifying license: " << licenseNumber << endl;
        kycCompleted = true;
        cout << "âœ… Delivery partner KYC completed!" << endl;
    }
    
    void startDelivery() {
        if (!kycCompleted) {
            cout << "âŒ Cannot start delivery - Complete KYC first!" << endl;
            return;
        }
        cout << "ğŸšš " << name << " started delivery on " << vehicleType << endl;
    }
    
    void displayUserInfo() override {
        Partner::displayUserInfo();
        cout << "ğŸšš Vehicle: " << vehicleType << endl;
    }
};

// ğŸª Restaurant Owner class
class RestaurantOwner : public Partner {
private:
    string restaurantName;
    string businessLicense;
    
public:
    RestaurantOwner(const string& n, const string& phone, const string& mail,
                   const string& restaurant, const string& license)
        : Partner(n, phone, mail), restaurantName(restaurant), businessLicense(license) {}
    
    void performKYC() override {
        cout << "ğŸ“‹ Performing restaurant owner KYC for " << name << endl;
        cout << "ğŸª Restaurant: " << restaurantName << endl;
        cout << "ğŸ“œ Verifying business license: " << businessLicense << endl;
        cout << "ğŸ’¼ Verifying tax documents..." << endl;
        kycCompleted = true;
        cout << "âœ… Restaurant owner KYC completed!" << endl;
    }
    
    void manageMenu() {
        if (!kycCompleted) {
            cout << "âŒ Complete KYC first before managing menu!" << endl;
            return;
        }
        cout << "ğŸ“‹ " << name << " is managing menu for " << restaurantName << endl;
    }
    
    void displayUserInfo() override {
        Partner::displayUserInfo();
        cout << "ğŸª Restaurant: " << restaurantName << endl;
    }
};

// âœ… LSP Compliant functions
void processUserLogin(User& user) {
    cout << "\nğŸ¯ PROCESSING USER LOGIN" << endl;
    cout << "========================" << endl;
    user.login();
    user.displayUserInfo();
    user.logout();
    cout << "âœ… Login process completed!" << endl;
}

void processPartnerOnboarding(Partner& partner) {
    cout << "\nğŸ¯ PROCESSING PARTNER ONBOARDING" << endl;
    cout << "=================================" << endl;
    partner.login();
    partner.displayUserInfo();
    
    if (!partner.isKYCCompleted()) {
        cout << "\nğŸ“‹ Starting KYC process..." << endl;
        partner.performKYC();
        cout << "âœ… Partner onboarding completed!" << endl;
    } else {
        cout << "â„¹ï¸  Partner already verified!" << endl;
    }
    
    partner.logout();
}

void processCustomerRegistration(Customer& customer) {
    cout << "\nğŸ¯ PROCESSING CUSTOMER REGISTRATION" << endl;
    cout << "===================================" << endl;
    customer.login();
    customer.displayUserInfo();
    cout << "âœ… Customer registration completed! No KYC needed!" << endl;
    customer.logout();
}

int main() {
    cout << "ğŸ½ï¸  SWIGGY USER SYSTEM - LSP COMPLIANT SOLUTION" << endl;
    cout << "===============================================" << endl;
    
    // Creating users
    Customer customer("Alice Johnson", "+91-9876543210", "alice@email.com");
    DeliveryPartner deliveryGuy("Bob Smith", "+91-8765432109", "bob@email.com",
                               "Motorcycle", "DL123456789");
    RestaurantOwner owner("Charlie Brown", "+91-7654321098", "charlie@email.com",
                         "Charlie's Pizza", "BL987654321");
    
    // âœ… All work perfectly with appropriate functions
    processCustomerRegistration(customer);      // No KYC needed
    processPartnerOnboarding(deliveryGuy);      // KYC required
    processPartnerOnboarding(owner);            // KYC required
    
    cout << "\nğŸ”¸ Testing generic user functions:" << endl;
    processUserLogin(customer);                 // âœ… Works
    processUserLogin(deliveryGuy);              // âœ… Works  
    processUserLogin(owner);                    // âœ… Works
    
    cout << "\nğŸ‰ All tests passed! LSP respected!" << endl;
    
    return 0;
}
```


***

## ğŸ“Š Visual Hierarchy Comparison

```mermaid
graph TD
    subgraph "âŒ LSP Violation"
        A[User with KYC] --> B[Customer]
        A --> C[DeliveryPartner]
        A --> D[RestaurantOwner]
        B --> E["performKYC() throws exception!"]
        E --> F["Contract broken ğŸ’¥"]
    end
    
    subgraph "âœ… LSP Compliant"
        G[User - Basic functionality] --> H[Customer]
        G --> I[Partner - KYC required]
        I --> J[DeliveryPartner]
        I --> K[RestaurantOwner]
        H --> L["No KYC methods âœ…"]
        J --> M["KYC implemented âœ…"]
        K --> N["KYC implemented âœ…"]
    end
```


***

## ğŸ¯ Key Principles Applied

### âœ… LSP Compliance Achieved:

1. **Proper Abstraction:** Separated concerns appropriately
2. **No Dummy Methods:** No forced empty implementations
3. **Substitutability:** Each class can replace its parent seamlessly
4. **Contract Preservation:** All methods work as expected

### ğŸ› ï¸ Design Benefits:

- **Clear Separation:** Customers vs Partners
- **Type Safety:** Can't call KYC on customers (compile-time check)
- **Extensibility:** Easy to add new partner types
- **Maintainability:** Changes don't break existing functionality

***

## ğŸ† Summary

**The LSP violation occurred because:**

- ğŸš« Base class (`User`) had methods not applicable to all subclasses
- ğŸš« `Customer` had to throw exceptions for unsupported operations
- ğŸš« Client code couldn't reliably substitute subclasses for base class

**The solution separates:**

- ğŸ‘¥ **Regular Users** (Customers) - Simple authentication
- ğŸ‘” **Business Partners** (Delivery \& Restaurant) - KYC required

**Result: Clean inheritance where every subclass can truly substitute its parent!** âœ¨

---
# ğŸ½ï¸ Swiggy User System: Complete LSP Analysis with Enhanced Graphs

## ğŸ“Š System Architecture Overview

```mermaid
graph TB
    subgraph "ğŸ½ï¸ Swiggy Platform"
        Platform[Swiggy Platform]
        Platform --> Users[User Management]
        Platform --> Orders[Order Management]
        Platform --> Delivery[Delivery System]
    end
    
    subgraph "ğŸ‘¥ User Types"
        Customer[ğŸ›’ Customer]
        DeliveryPartner[ğŸšš Delivery Partner]
        RestaurantOwner[ğŸª Restaurant Owner]
    end
    
    Customer --> Orders
    DeliveryPartner --> Delivery
    RestaurantOwner --> Orders
```

***

## âŒ PROBLEMATIC DESIGN: LSP Violation

### ğŸ”´ Inheritance Hierarchy (Wrong Approach)

```mermaid
graph TD
    A["ğŸ‘¤ User<br/>- login()<br/>- logout()<br/>- performKYC() ğŸš¨<br/>- displayUserInfo()"] 
    
    A --> B["ğŸ›’ Customer<br/>- placeOrder()<br/>- performKYC() throws exception! ğŸ’¥"]
    A --> C["ğŸšš DeliveryPartner<br/>- startDelivery()<br/>- performKYC() âœ…"]
    A --> D["ğŸª RestaurantOwner<br/>- manageMenu()<br/>- performKYC() âœ…"]
    
    B --> E["âŒ LSP Violation!<br/>Customer breaks contract"]
    
    classDef violation fill:#ffcccc,stroke:#ff0000,stroke-width:2px
    classDef working fill:#ccffcc,stroke:#00ff00,stroke-width:2px
    
    class B,E violation
    class C,D working
```

### ğŸš¨ Problem Flow Diagram

```mermaid
sequenceDiagram
    participant Client
    participant User as User (Base)
    participant Customer
    participant Partner as DeliveryPartner
    
    Note over Client: processUserRegistration(User& user)
    
    Client->>Customer: performKYC()
    Customer-->>Client: âŒ Exception thrown!
    Note over Customer: "KYC not required for customers"
    
    Client->>Partner: performKYC()
    Partner-->>Client: âœ… Success
    Note over Partner: KYC completed
    
    Note over Client: âŒ LSP VIOLATED!<br/>Customer cannot substitute User
```

***

## âŒ LSP VIOLATION CODE (Enhanced Version)

```cpp
#include <iostream>
#include <string>
#include <stdexcept>
#include <vector>
#include <memory>
using namespace std;

// ğŸš¨ PROBLEMATIC BASE CLASS - Forces KYC on all users
class User {
protected:
    string name;
    string phoneNumber;
    string email;
    bool kycCompleted;
    string userType;
    
public:
    User(const string& n, const string& phone, const string& mail, const string& type) 
        : name(n), phoneNumber(phone), email(mail), kycCompleted(false), userType(type) {
        cout << "ğŸ†• Creating " << userType << ": " << name << endl;
    }
    
    virtual void login() {
        cout << "ğŸ” " << name << " (" << userType << ") logged in!" << endl;
    }
    
    virtual void logout() {
        cout << "ğŸ‘‹ " << name << " logged out!" << endl;
    }
    
    // ğŸš¨ PROBLEM: All users forced to have KYC method
    virtual void performKYC() {
        cout << "ğŸ“‹ Performing KYC for " << name << " (" << userType << ")" << endl;
        cout << "ğŸ“„ Document verification in progress..." << endl;
        kycCompleted = true;
        cout << "âœ… KYC completed for " << name << endl;
    }
    
    virtual void displayUserInfo() {
        cout << "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”" << endl;
        cout << "â”‚ ğŸ‘¤ User: " << name << endl;
        cout << "â”‚ ğŸ“ Phone: " << phoneNumber << endl;
        cout << "â”‚ ğŸ“§ Email: " << email << endl;
        cout << "â”‚ ğŸ·ï¸  Type: " << userType << endl;
        cout << "â”‚ ğŸ†” KYC: " << (kycCompleted ? "âœ… Completed" : "âŒ Pending") << endl;
        cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" << endl;
    }
    
    bool isKYCCompleted() const { return kycCompleted; }
    string getUserType() const { return userType; }
    virtual ~User() = default;
};

// ğŸ‘¥ Customer class - KYC not needed!
class Customer : public User {
private:
    vector<string> orderHistory;
    
public:
    Customer(const string& n, const string& phone, const string& mail)
        : User(n, phone, mail, "Customer") {}
    
    // ğŸš¨ LSP VIOLATION: Customers don't need KYC!
    void performKYC() override {
        cout << "âš ï¸  WARNING: Customers don't need KYC verification!" << endl;
        cout << "ğŸš« This operation is not supported for customers!" << endl;
        cout << "ğŸ’¡ Customers can order without KYC verification" << endl;
        // Throwing exception breaks LSP!
        throw runtime_error("KYC not required for customers - Operation not supported!");
    }
    
    void placeOrder(const string& restaurant) {
        cout << "ğŸ›’ " << name << " browsing " << restaurant << "..." << endl;
        orderHistory.push_back(restaurant);
        cout << "ğŸ• Order placed from " << restaurant << "!" << endl;
    }
    
    void viewOrderHistory() {
        cout << "ğŸ“š Order History for " << name << ":" << endl;
        for (size_t i = 0; i < orderHistory.size(); ++i) {
            cout << "  " << (i+1) << ". " << orderHistory[i] << endl;
        }
    }
};

// ğŸšš Delivery Partner class - KYC needed
class DeliveryPartner : public User {
private:
    string vehicleType;
    string licenseNumber;
    int deliveryCount;
    
public:
    DeliveryPartner(const string& n, const string& phone, const string& mail, 
                   const string& vehicle, const string& license)
        : User(n, phone, mail, "Delivery Partner"), vehicleType(vehicle), 
          licenseNumber(license), deliveryCount(0) {}
    
    void performKYC() override {
        cout << "ğŸ“‹ Performing detailed KYC for delivery partner " << name << endl;
        cout << "ğŸ†” Verifying identity documents..." << endl;
        cout << "ğŸš— Verifying vehicle: " << vehicleType << endl;
        cout << "ğŸªª  Verifying license: " << licenseNumber << endl;
        cout << "ğŸ” Background verification..." << endl;
        kycCompleted = true;
        cout << "âœ… Delivery Partner KYC completed! Ready for assignments!" << endl;
    }
    
    void startDelivery(const string& orderId) {
        if (!kycCompleted) {
            cout << "âŒ Cannot start delivery - KYC not completed!" << endl;
            return;
        }
        cout << "ğŸšš " << name << " started delivery #" << orderId << " on " << vehicleType << endl;
        deliveryCount++;
    }
    
    void displayUserInfo() override {
        User::displayUserInfo();
        cout << "ğŸš— Vehicle: " << vehicleType << endl;
        cout << "ğŸ“Š Deliveries: " << deliveryCount << endl;
    }
};

// ğŸª Restaurant Owner class - KYC needed
class RestaurantOwner : public User {
private:
    string restaurantName;
    string businessLicense;
    vector<string> menuItems;
    
public:
    RestaurantOwner(const string& n, const string& phone, const string& mail,
                   const string& restaurant, const string& license)
        : User(n, phone, mail, "Restaurant Owner"), restaurantName(restaurant), 
          businessLicense(license) {}
    
    void performKYC() override {
        cout << "ğŸ“‹ Performing business KYC for " << name << endl;
        cout << "ğŸª Restaurant: " << restaurantName << endl;
        cout << "ğŸ“œ Verifying business license: " << businessLicense << endl;
        cout << "ğŸ’¼ Verifying tax documents..." << endl;
        cout << "ğŸ½ï¸  Inspecting food safety compliance..." << endl;
        kycCompleted = true;
        cout << "âœ… Business KYC completed! Restaurant ready for orders!" << endl;
    }
    
    void addMenuItem(const string& item) {
        if (!kycCompleted) {
            cout << "âŒ Complete KYC first before managing menu!" << endl;
            return;
        }
        menuItems.push_back(item);
        cout << "ğŸ“‹ Added '" << item << "' to " << restaurantName << " menu" << endl;
    }
    
    void displayUserInfo() override {
        User::displayUserInfo();
        cout << "ğŸª Restaurant: " << restaurantName << endl;
        cout << "ğŸ“‹ Menu Items: " << menuItems.size() << endl;
    }
};

// ğŸ§ª Function that demonstrates LSP violation
void processUserRegistration(User& user) {
    cout << "\nğŸ¯ PROCESSING USER REGISTRATION" << endl;
    cout << "================================" << endl;
    
    user.login();
    user.displayUserInfo();
    
    cout << "\nğŸ“‹ Starting mandatory KYC process..." << endl;
    try {
        user.performKYC();  // ğŸ’¥ This will break for Customer!
        cout << "âœ… Registration completed successfully!" << endl;
        
        // Additional verification
        if (user.isKYCCompleted()) {
            cout << "ğŸ‰ " << user.getUserType() << " is now fully verified!" << endl;
        }
        
    } catch (const exception& e) {
        cout << "ğŸ’¥ REGISTRATION FAILED: " << e.what() << endl;
        cout << "ğŸš« " << user.getUserType() << " registration incomplete!" << endl;
    }
    
    user.logout();
    cout << "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" << endl;
}

// ğŸ“Š Statistics tracker
class RegistrationStats {
private:
    int successful = 0;
    int failed = 0;
    vector<string> failedUsers;
    
public:
    void recordSuccess() { successful++; }
    void recordFailure(const string& userType) { 
        failed++; 
        failedUsers.push_back(userType);
    }
    
    void displayStats() {
        cout << "\nğŸ“Š REGISTRATION STATISTICS" << endl;
        cout << "=========================" << endl;
        cout << "âœ… Successful: " << successful << endl;
        cout << "âŒ Failed: " << failed << endl;
        cout << "ğŸ“ˆ Success Rate: " << (successful * 100.0 / (successful + failed)) << "%" << endl;
        
        if (!failedUsers.empty()) {
            cout << "ğŸ’¥ Failed User Types: ";
            for (const auto& user : failedUsers) {
                cout << user << " ";
            }
            cout << endl;
        }
    }
};

int main() {
    cout << "ğŸ½ï¸  SWIGGY USER SYSTEM - LSP VIOLATION DEMO" << endl;
    cout << "===========================================" << endl;
    
    RegistrationStats stats;
    
    // Creating different types of users
    Customer customer("Alice Johnson", "+91-9876543210", "alice@email.com");
    DeliveryPartner deliveryGuy("Bob Smith", "+91-8765432109", "bob@email.com", 
                               "Motorcycle", "DL123456789");
    RestaurantOwner owner("Charlie Brown", "+91-7654321098", "charlie@email.com",
                         "Charlie's Pizza", "BL987654321");
    
    // Store users in a vector to demonstrate polymorphism failure
    vector<unique_ptr<User>> users;
    users.push_back(make_unique<Customer>(customer));
    users.push_back(make_unique<DeliveryPartner>(deliveryGuy));
    users.push_back(make_unique<RestaurantOwner>(owner));
    
    cout << "\nğŸ”„ BULK PROCESSING ALL USERS (Polymorphic approach)" << endl;
    
    for (auto& user : users) {
        try {
            processUserRegistration(*user);
            stats.recordSuccess();
        } catch (...) {
            stats.recordFailure(user->getUserType());
        }
    }
    
    stats.displayStats();
    
    cout << "\nğŸ¯ CONCLUSION: LSP VIOLATED!" << endl;
    cout << "âŒ Customer cannot substitute User without breaking functionality" << endl;
    cout << "âŒ Polymorphic processing fails for Customer objects" << endl;
    cout << "âŒ Exception handling required for 'normal' operations" << endl;
    
    return 0;
}
```

***

## âœ… LSP COMPLIANT SOLUTION (Enhanced Version)

### ğŸŸ¢ Correct Inheritance Hierarchy

```mermaid
graph TD
    A["ğŸ‘¤ User<br/>- login()<br/>- logout()<br/>- displayUserInfo()"] 
    
    A --> B["ğŸ›’ Customer<br/>- placeOrder()<br/>- viewOrderHistory()"]
    A --> C["ğŸ‘” Partner<br/>- performKYC() (abstract)<br/>- isKYCCompleted()"]
    
    C --> D["ğŸšš DeliveryPartner<br/>- performKYC() âœ…<br/>- startDelivery()"]
    C --> E["ğŸª RestaurantOwner<br/>- performKYC() âœ…<br/>- manageMenu()"]
    
    classDef base fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef customer fill:#f3e5f5,stroke:#4a148c,stroke-width:2px
    classDef partner fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    
    class A base
    class B customer
    class C,D,E partner
```

### ğŸ”„ Correct Process Flow

```mermaid
sequenceDiagram
    participant Client
    participant User as User (Base)
    participant Customer
    participant Partner
    
    Note over Client: processUserLogin(User& user)
    
    Client->>User: login()
    User-->>Client: âœ… Success
    
    Client->>Customer: login() (as User)
    Customer-->>Client: âœ… Success
    
    Client->>Partner: login() (as User)  
    Partner-->>Client: âœ… Success
    
    Note over Client: âœ… LSP RESPECTED!<br/>All substitutions work
    
    rect rgb(200, 255, 200)
        Note over Client: processPartnerOnboarding(Partner& partner)
        Client->>Partner: performKYC()
        Partner-->>Client: âœ… KYC Completed
    end
```

### ğŸ“Š System Component Interaction

```mermaid
graph LR
    subgraph "ğŸ­ User Management System"
        UserService[User Service]
        AuthService[Authentication Service]
        KYCService[KYC Service]
    end
    
    subgraph "ğŸ‘¥ User Types"
        Customer[ğŸ›’ Customer]
        DeliveryPartner[ğŸšš Delivery Partner]  
        RestaurantOwner[ğŸª Restaurant Owner]
    end
    
    Customer --> UserService
    Customer --> AuthService
    
    DeliveryPartner --> UserService
    DeliveryPartner --> AuthService
    DeliveryPartner --> KYCService
    
    RestaurantOwner --> UserService
    RestaurantOwner --> AuthService
    RestaurantOwner --> KYCService
    
    style Customer fill:#f9f,stroke:#333,stroke-width:2px
    style DeliveryPartner fill:#bbf,stroke:#333,stroke-width:2px
    style RestaurantOwner fill:#bfb,stroke:#333,stroke-width:2px
```

***

## âœ… COMPLETE LSP COMPLIANT CODE

```cpp
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <algorithm>
using namespace std;

// ğŸ¯ Base User class - Only common functionality
class User {
protected:
    string name;
    string phoneNumber;
    string email;
    string userType;
    
public:
    User(const string& n, const string& phone, const string& mail, const string& type)
        : name(n), phoneNumber(phone), email(mail), userType(type) {
        cout << "ğŸ†• Creating " << userType << ": " << name << endl;
    }
    
    virtual void login() {
        cout << "ğŸ” " << name << " (" << userType << ") logged in!" << endl;
    }
    
    virtual void logout() {
        cout << "ğŸ‘‹ " << name << " logged out!" << endl;
    }
    
    virtual void displayUserInfo() {
        cout << "â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”" << endl;
        cout << "â”‚ ğŸ‘¤ User: " << name << endl;
        cout << "â”‚ ğŸ“ Phone: " << phoneNumber << endl;
        cout << "â”‚ ğŸ“§ Email: " << email << endl;
        cout << "â”‚ ğŸ·ï¸  Type: " << userType << endl;
        cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" << endl;
    }
    
    string getName() const { return name; }
    string getUserType() const { return userType; }
    virtual ~User() = default;
};

// ğŸ’¼ Partner class - For users who need KYC (Business partners)
class Partner : public User {
protected:
    bool kycCompleted;
    string kycDocuments;
    
public:
    Partner(const string& n, const string& phone, const string& mail, const string& type)
        : User(n, phone, mail, type), kycCompleted(false) {}
    
    virtual void performKYC() = 0;  // Pure virtual - must implement
    
    bool isKYCCompleted() const { return kycCompleted; }
    
    void displayUserInfo() override {
        User::displayUserInfo();
        cout << "â”‚ ğŸ†” KYC: " << (kycCompleted ? "âœ… Completed" : "âŒ Pending") << endl;
        cout << "â”‚ ğŸ‘” Category: Business Partner" << endl;
        cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" << endl;
    }
    
    virtual void getPartnerBenefits() {
        if (kycCompleted) {
            cout << "ğŸ Partner benefits activated!" << endl;
        } else {
            cout << "â³ Complete KYC to unlock partner benefits" << endl;
        }
    }
};

// ğŸ‘¥ Customer class - No KYC needed!
class Customer : public User {
private:
    vector<string> orderHistory;
    int loyaltyPoints;
    
public:
    Customer(const string& n, const string& phone, const string& mail)
        : User(n, phone, mail, "Customer"), loyaltyPoints(0) {}
    
    void placeOrder(const string& restaurant, const string& items) {
        cout << "ğŸ›’ " << name << " browsing " << restaurant << "..." << endl;
        cout << "ğŸ• Ordering: " << items << endl;
        orderHistory.push_back(restaurant + " - " + items);
        loyaltyPoints += 10;
        cout << "âœ… Order placed! (+10 loyalty points)" << endl;
    }
    
    void viewOrderHistory() {
        cout << "ğŸ“š Order History for " << name << " (" << orderHistory.size() << " orders):" << endl;
        for (size_t i = 0; i < orderHistory.size(); ++i) {
            cout << "  " << (i+1) << ". " << orderHistory[i] << endl;
        }
    }
    
    void displayUserInfo() override {
        User::displayUserInfo();
        cout << "â”‚ ğŸ›ï¸  Orders: " << orderHistory.size() << endl;
        cout << "â”‚ â­ Loyalty Points: " << loyaltyPoints << endl;
        cout << "â”‚ ğŸ¯ Special: No KYC Required!" << endl;
        cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" << endl;
    }
    
    void redeemLoyaltyPoints(int points) {
        if (points <= loyaltyPoints) {
            loyaltyPoints -= points;
            cout << "ğŸ‰ Redeemed " << points << " points! Remaining: " << loyaltyPoints << endl;
        } else {
            cout << "âŒ Insufficient loyalty points!" << endl;
        }
    }
};

// ğŸšš Delivery Partner class
class DeliveryPartner : public Partner {
private:
    string vehicleType;
    string licenseNumber;
    int deliveryCount;
    vector<string> deliveryZones;
    
public:
    DeliveryPartner(const string& n, const string& phone, const string& mail,
                   const string& vehicle, const string& license)
        : Partner(n, phone, mail, "Delivery Partner"), vehicleType(vehicle), 
          licenseNumber(license), deliveryCount(0) {}
    
    void performKYC() override {
        cout << "ğŸ“‹ Performing delivery partner KYC for " << name << endl;
        cout << "ğŸ†” Verifying identity documents..." << endl;
        cout << "ğŸš— Verifying vehicle: " << vehicleType << endl;
        cout << "ğŸªª  Verifying license: " << licenseNumber << endl;
        cout << "ğŸ” Background verification in progress..." << endl;
        cout << "ğŸ“± Installing delivery app and tracking system..." << endl;
        kycCompleted = true;
        kycDocuments = "ID, Vehicle Registration, License";
        cout << "âœ… Delivery Partner KYC completed successfully!" << endl;
    }
    
    void addDeliveryZone(const string& zone) {
        if (!kycCompleted) {
            cout << "âŒ Complete KYC first!" << endl;
            return;
        }
        deliveryZones.push_back(zone);
        cout << "ğŸ“ Added delivery zone: " << zone << endl;
    }
    
    void startDelivery(const string& orderId) {
        if (!kycCompleted) {
            cout << "âŒ Cannot start delivery - Complete KYC first!" << endl;
            return;
        }
        cout << "ğŸšš " << name << " started delivery #" << orderId << " on " << vehicleType << endl;
        deliveryCount++;
        cout << "ğŸ“Š Total deliveries: " << deliveryCount << endl;
    }
    
    void displayUserInfo() override {
        Partner::displayUserInfo();
        cout << "â”‚ ğŸš— Vehicle: " << vehicleType << endl;
        cout << "â”‚ ğŸ“Š Deliveries: " << deliveryCount << endl;
        cout << "â”‚ ğŸ“ Zones: " << deliveryZones.size() << endl;
        cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" << endl;
    }
};

// ğŸª Restaurant Owner class
class RestaurantOwner : public Partner {
private:
    string restaurantName;
    string businessLicense;
    vector<string> menuItems;
    vector<string> cuisineTypes;
    
public:
    RestaurantOwner(const string& n, const string& phone, const string& mail,
                   const string& restaurant, const string& license)
        : Partner(n, phone, mail, "Restaurant Owner"), restaurantName(restaurant), 
          businessLicense(license) {}
    
    void performKYC() override {
        cout << "ğŸ“‹ Performing business KYC for " << name << endl;
        cout << "ğŸª Restaurant: " << restaurantName << endl;
        cout << "ğŸ“œ Verifying business license: " << businessLicense << endl;
        cout << "ğŸ’¼ Checking tax compliance..." << endl;
        cout << "ğŸ½ï¸  Food safety inspection..." << endl;
        cout << "ğŸ“‹ Menu approval process..." << endl;
        kycCompleted = true;
        kycDocuments = "Business License, Tax Certificate, Food License";
        cout << "âœ… Restaurant KYC completed! Ready for business!" << endl;
    }
    
    void addMenuItem(const string& item, const string& cuisine) {
        if (!kycCompleted) {
            cout << "âŒ Complete KYC first before managing menu!" << endl;
            return;
        }
        menuItems.push_back(item);
        if (find(cuisineTypes.begin(), cuisineTypes.end(), cuisine) == cuisineTypes.end()) {
            cuisineTypes.push_back(cuisine);
        }
        cout << "ğŸ“‹ Added '" << item << "' (" << cuisine << ") to " << restaurantName << " menu" << endl;
    }
    
    void displayUserInfo() override {
        Partner::displayUserInfo();
        cout << "â”‚ ğŸª Restaurant: " << restaurantName << endl;
        cout << "â”‚ ğŸ“‹ Menu Items: " << menuItems.size() << endl;
        cout << "â”‚ ğŸ½ï¸  Cuisines: " << cuisineTypes.size() << endl;
        cout << "â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜" << endl;
    }
};

// âœ… LSP Compliant functions
void processUserLogin(User& user) {
    cout << "\nğŸ¯ PROCESSING USER LOGIN" << endl;
    cout << "========================" << endl;
    user.login();
    user.displayUserInfo();
    user.logout();
    cout << "âœ… Login process completed successfully!" << endl;
}

void processPartnerOnboarding(Partner& partner) {
    cout << "\nğŸ¯ PROCESSING PARTNER ONBOARDING" << endl;
    cout << "=================================" << endl;
    partner.login();
    partner.displayUserInfo();
    
    if (!partner.isKYCCompleted()) {
        cout << "\nğŸ“‹ Initiating KYC verification..." << endl;
        partner.performKYC();
        cout << "ğŸ‰ Partner onboarding completed successfully!" << endl;
        partner.getPartnerBenefits();
    } else {
        cout << "â„¹ï¸  Partner already verified and active!" << endl;
    }
    
    partner.logout();
}

void processCustomerRegistration(Customer& customer) {
    cout << "\nğŸ¯ PROCESSING CUSTOMER REGISTRATION" << endl;
    cout << "===================================" << endl;
    customer.login();
    customer.displayUserInfo();
    cout << "âœ… Customer registration completed! Ready to order!" << endl;
    cout << "ğŸ¯ No KYC required - Start ordering immediately!" << endl;
    customer.logout();
}

// ğŸ“Š Enhanced Statistics
class SystemStats {
private:
    int totalUsers = 0;
    int customers = 0;
    int partners = 0;
    int kycCompleted = 0;
    
public:
    void recordUser(const string& type, bool kyc = false) {
        totalUsers++;
        if (type == "Customer") customers++;
        else { partners++; if (kyc) kycCompleted++; }
    }
    
    void displaySystemStats() {
        cout << "\nğŸ“ˆ SWIGGY SYSTEM STATISTICS" << endl;
        cout << "===========================" << endl;
        cout << "ğŸ‘¥ Total Users: " << totalUsers << endl;
        cout << "ğŸ›’ Customers: " << customers << " (" << (customers*100.0/totalUsers) << "%)" << endl;
        cout << "ğŸ‘” Partners: " << partners << " (" << (partners*100.0/totalUsers) << "%)" << endl;
        cout << "âœ… KYC Completed: " << kycCompleted << "/" << partners << " partners" << endl;
        cout << "ğŸ¯ System Health: " << (totalUsers > 0 ? "âœ… HEALTHY" : "âš ï¸  NO USERS") << endl;
    }
};

int main() {
    cout << "ğŸ½ï¸  SWIGGY USER SYSTEM - LSP COMPLIANT SOLUTION" << endl;
    cout << "===============================================" << endl;
    
    SystemStats stats;
    
    // Creating users with enhanced details
    Customer customer("Alice Johnson", "+91-9876543210", "alice@email.com");
    DeliveryPartner deliveryGuy("Bob Smith", "+91-8765432109", "bob@email.com",
                               "Electric Scooter", "DL123456789");
    RestaurantOwner owner("Charlie Brown", "+91-7654321098", "charlie@email.com",
                         "Charlie's Authentic Pizza", "BL987654321");
    
    // âœ… Process each user type with appropriate functions
    processCustomerRegistration(customer);
    stats.recordUser("Customer");
    
    processPartnerOnboarding(deliveryGuy);
    stats.recordUser("Delivery Partner", true);
    
    processPartnerOnboarding(owner);
    stats.recordUser("Restaurant Owner", true);
    
    cout << "\nğŸ”¸ Testing LSP: All users work with base User functions" << endl;
    
    // âœ… All work perfectly with User interface (LSP respected!)
    vector<reference_wrapper<User>> allUsers = {customer, deliveryGuy, owner};
    
    for (User& user : allUsers) {
        processUserLogin(user);
        cout << "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€" << endl;
    }
    
    // ğŸ¯ Demonstrate specific functionalities
    cout << "\nğŸ² TESTING SPECIFIC FUNCTIONALITIES" << endl;
    cout << "===================================" << endl;
    
    customer.placeOrder("Pizza Palace", "Margherita Pizza, Garlic Bread");
    customer.placeOrder("Burger Junction", "Cheese Burger, Fries");
    customer.viewOrderHistory();
    customer.redeemLoyaltyPoints(15);
    
    deliveryGuy.addDeliveryZone("Downtown");
    deliveryGuy.addDeliveryZone("Tech Park");
    deliveryGuy.startDelivery("ORD001");
    
    owner.addMenuItem("Margherita Pizza", "Italian");
    owner.addMenuItem("Chicken Tikka", "Indian");
    owner.addMenuItem("Caesar Salad", "Continental");
    
    stats.displaySystemStats();
    
    cout << "\nğŸ‰ SUCCESS: ALL TESTS PASSED!" << endl;
    cout << "âœ… LSP respected: All subclasses substitute their parents perfectly" << endl;
    cout << "âœ… No forced implementations or dummy methods" << endl;
    cout << "âœ… Clear separation of concerns" << endl;
    cout << "âœ… Type safety enforced at compile time" << endl;
    
    return 0;
}
```

***

## ğŸ“Š Comprehensive Comparison Chart

### ğŸ”´ LSP Violation Impact

```mermaid
pie title LSP Violation Impact Analysis
    "Successful Operations" : 66.7
    "Failed Operations" : 33.3
```

### ğŸŸ¢ LSP Compliant Benefits

```mermaid
pie title LSP Compliant Success Rate
    "Successful Operations" : 100
    "Failed Operations" : 0
```

***

## ğŸ¯ Key Benefits Analysis

| Aspect | âŒ LSP Violation | âœ… LSP Compliant |
|--------|-----------------|------------------|
| **Substitutability** | Customer breaks User contract | Perfect substitution |
| **Exception Handling** | Required for normal operations | Not needed |
| **Code Maintenance** | High - fragile inheritance | Low - clean separation |
| **Testing** | Complex - need exception cases | Simple - predictable behavior |
| **Extensibility** | Difficult - breaks existing code | Easy - clear contracts |
| **Team Development** | Risky - breaking changes | Safe - independent work |

***

## ğŸ† Final Architecture Overview

```mermaid
graph TB
    subgraph "ğŸ½ï¸ Swiggy Ecosystem"
        Platform[Swiggy Platform]
        
        subgraph "ğŸ‘¥ User Management"
            UserService[User Service]
            AuthService[Auth Service]  
            KYCService[KYC Service]
        end
        
        subgraph "ğŸ›’ Customer Flow"
            Customer[Customer]
            OrderService[Order Service]
            PaymentService[Payment Service]
        end
        
        subgraph "ğŸ‘” Partner Flow"  
            Partner[Partner Base]
            DeliveryPartner[Delivery Partner]
            RestaurantOwner[Restaurant Owner]
        end
        
        Platform --> UserService
        UserService --> Customer
        UserService --> Partner
        
        Customer --> OrderService
        Customer --> PaymentService
        Customer -.-> AuthService
        
        Partner --> DeliveryPartner
        Partner --> RestaurantOwner
        DeliveryPartner --> KYCService
        RestaurantOwner --> KYCService
        DeliveryPartner -.-> AuthService
        RestaurantOwner -.-> AuthService
    end
    
    classDef customer fill:#e1f5fe,stroke:#01579b,stroke-width:2px
    classDef partner fill:#e8f5e8,stroke:#1b5e20,stroke-width:2px
    classDef service fill:#fff3e0,stroke:#e65100,stroke-width:2px
    
    class Customer customer
    class Partner,DeliveryPartner,RestaurantOwner partner
    class UserService,AuthService,KYCService,OrderService,PaymentService service
```

***

## ğŸŠ Conclusion

### âœ… LSP Compliance Achieved Through:

1. **ğŸ¯ Proper Abstraction Levels**
   - Base `User` class with only common functionality
   - `Partner` class for KYC-requiring users
   - Clear separation of concerns

2. **ğŸ”„ Perfect Substitutability**
   - Any `Customer` can replace `User` seamlessly
   - Any `Partner` subclass works interchangeably
   - No exceptions or broken contracts

3. **ğŸ›¡ï¸ Type Safety**
   - Compile-time prevention of invalid operations
   - No runtime exceptions for normal operations
   - Clear interface contracts

4. **ğŸ“ˆ Maintainable Design**
   - Easy to extend with new user types
   - Independent development possible
   - Minimal breaking changes

**Result: A robust, scalable, and maintainable user management system that respects the Liskov Substitution Principle!** ğŸš€âœ¨

---